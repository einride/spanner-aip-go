package musicdb

// Code generated by aip-spanner-go. DO NOT EDIT.

import (
	"context"
	"fmt"
	"strings"

	"cloud.google.com/go/spanner"
	"cloud.google.com/go/spanner/spansql"
	"google.golang.org/api/iterator"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

type SingersReadTransaction struct {
	Tx SpannerReadTransaction
}

func (t SingersReadTransaction) Read(
	ctx context.Context,
	keySet spanner.KeySet,
) *SingersRowIterator {
	return &SingersRowIterator{
		RowIterator: t.Tx.Read(
			ctx,
			"Singers",
			keySet,
			((*SingersRow)(nil)).ColumnNames(),
		),
	}
}

func (t SingersReadTransaction) Get(
	ctx context.Context,
	key SingersPrimaryKey,
) (*SingersRow, error) {
	spannerRow, err := t.Tx.ReadRow(
		ctx,
		"Singers",
		key.SpannerKey(),
		((*SingersRow)(nil)).ColumnNames(),
	)
	if err != nil {
		return nil, err
	}
	var row SingersRow
	if err := row.UnmarshalSpannerRow(spannerRow); err != nil {
		return nil, err
	}
	return &row, nil
}

func (t SingersReadTransaction) BatchGet(
	ctx context.Context,
	keys []SingersPrimaryKey,
) ([]*SingersRow, error) {
	spannerKeys := make([]spanner.KeySet, 0, len(keys))
	for _, key := range keys {
		spannerKeys = append(spannerKeys, key.SpannerKey())
	}
	it := t.Read(ctx, spanner.KeySets(spannerKeys...))
	defer it.Stop()
	foundRows := make(map[SingersPrimaryKey]*SingersRow, len(keys))
	if err := it.Do(func(row *SingersRow) error {
		foundRows[row.PrimaryKey()] = row
		return nil
	}); err != nil {
		return nil, err
	}
	rows := make([]*SingersRow, 0, len(keys))
	for _, key := range keys {
		row, ok := foundRows[key]
		if !ok {
			return nil, status.Errorf(codes.NotFound, "not found: %v", key)
		}
		rows = append(rows, row)
	}
	return rows, nil
}

func (t SingersReadTransaction) List(
	ctx context.Context,
	query ListQuery,
) *SingersRowIterator {
	stmt := spanner.Statement{
		SQL: spansql.Query{
			Select: spansql.Select{
				List: ((*SingersRow)(nil)).ColumnExprs(),
				From: []spansql.SelectFrom{
					spansql.SelectFromTable{Table: "Singers"},
				},
				Where: query.Where,
			},
			Order:  query.Order,
			Limit:  spansql.Param("limit"),
			Offset: spansql.Param("offset"),
		}.SQL(),
		Params: map[string]interface{}{
			"limit":  query.Limit,
			"offset": query.Offset,
		},
	}
	return &SingersRowIterator{
		RowIterator: t.Tx.Query(ctx, stmt),
	}
}

type SingersRowIterator struct {
	*spanner.RowIterator
}

func (i *SingersRowIterator) Next() (*SingersRow, error) {
	spannerRow, err := i.RowIterator.Next()
	if err != nil {
		return nil, err
	}
	var row SingersRow
	if err := row.UnmarshalSpannerRow(spannerRow); err != nil {
		return nil, err
	}
	return &row, nil
}

func (i *SingersRowIterator) Do(f func(row *SingersRow) error) error {
	return i.RowIterator.Do(func(spannerRow *spanner.Row) error {
		var row SingersRow
		if err := row.UnmarshalSpannerRow(spannerRow); err != nil {
			return err
		}
		return f(&row)
	})
}

type SingersPrimaryKey struct {
	SingerId int64
}

func (k SingersPrimaryKey) SpannerKey() spanner.Key {
	return spanner.Key{
		k.SingerId,
	}
}

func (k SingersPrimaryKey) SpannerKeySet() spanner.KeySet {
	return k.SpannerKey()
}

func (k SingersPrimaryKey) BoolExpr() spansql.BoolExpr {
	b := spansql.BoolExpr(spansql.ComparisonOp{
		Op:  spansql.Eq,
		LHS: spansql.ID("SingerId"),
		RHS: spansql.IntegerLiteral(k.SingerId),
	})
	return spansql.Paren{Expr: b}
}

func (k SingersPrimaryKey) QualifiedBoolExpr(prefix spansql.PathExp) spansql.BoolExpr {
	b := spansql.BoolExpr(spansql.ComparisonOp{
		Op:  spansql.Eq,
		LHS: append(prefix, spansql.ID("SingerId")),
		RHS: spansql.IntegerLiteral(k.SingerId),
	})
	return spansql.Paren{Expr: b}
}

type SingersPartialKey struct {
	SingerId int64
}

func (k SingersPartialKey) SpannerKey() spanner.Key {
	return spanner.Key{k.SingerId}
}

func (k SingersPartialKey) BoolExpr() spansql.BoolExpr {
	b := spansql.BoolExpr(spansql.ComparisonOp{
		Op:  spansql.Eq,
		LHS: spansql.ID("SingerId"),
		RHS: spansql.IntegerLiteral(k.SingerId),
	})
	return spansql.Paren{Expr: b}
}

func (k SingersPartialKey) QualifiedBoolExpr(prefix spansql.PathExp) spansql.BoolExpr {
	b := spansql.BoolExpr(spansql.ComparisonOp{
		Op:  spansql.Eq,
		LHS: append(prefix, spansql.ID("SingerId")),
		RHS: spansql.IntegerLiteral(k.SingerId),
	})
	return spansql.Paren{Expr: b}
}

type SingersKeyRange struct {
	Start SingersPartialKey
	End   SingersPartialKey
	Kind  spanner.KeyRangeKind
}

func (k SingersKeyRange) SpannerKeySet() spanner.KeySet {
	return spanner.KeyRange{
		Start: k.Start.SpannerKey(),
		End:   k.End.SpannerKey(),
		Kind:  k.Kind,
	}
}

type SingersRow struct {
	SingerId   int64              `spanner:"SingerId"`
	FirstName  spanner.NullString `spanner:"FirstName"`
	LastName   spanner.NullString `spanner:"LastName"`
	SingerInfo []uint8            `spanner:"SingerInfo"`
}

func (*SingersRow) ColumnNames() []string {
	return []string{
		"SingerId",
		"FirstName",
		"LastName",
		"SingerInfo",
	}
}

func (*SingersRow) ColumnIDs() []spansql.ID {
	return []spansql.ID{
		"SingerId",
		"FirstName",
		"LastName",
		"SingerInfo",
	}
}

func (*SingersRow) ColumnExprs() []spansql.Expr {
	return []spansql.Expr{
		spansql.ID("SingerId"),
		spansql.ID("FirstName"),
		spansql.ID("LastName"),
		spansql.ID("SingerInfo"),
	}
}

func (r *SingersRow) Validate() error {
	if !r.FirstName.IsNull() && len(r.FirstName.StringVal) > 1024 {
		return fmt.Errorf("column FirstName length > 1024")
	}
	if !r.LastName.IsNull() && len(r.LastName.StringVal) > 1024 {
		return fmt.Errorf("column LastName length > 1024")
	}
	return nil
}

func (r *SingersRow) UnmarshalSpannerRow(row *spanner.Row) error {
	for i := 0; i < row.Size(); i++ {
		switch row.ColumnName(i) {
		case "SingerId":
			if err := row.Column(i, &r.SingerId); err != nil {
				return fmt.Errorf("unmarshal Singers row: SingerId column: %w", err)
			}
		case "FirstName":
			if err := row.Column(i, &r.FirstName); err != nil {
				return fmt.Errorf("unmarshal Singers row: FirstName column: %w", err)
			}
		case "LastName":
			if err := row.Column(i, &r.LastName); err != nil {
				return fmt.Errorf("unmarshal Singers row: LastName column: %w", err)
			}
		case "SingerInfo":
			if err := row.Column(i, &r.SingerInfo); err != nil {
				return fmt.Errorf("unmarshal Singers row: SingerInfo column: %w", err)
			}
		default:
			return fmt.Errorf("unmarshal Singers row: unhandled column: %s", row.ColumnName(i))
		}
	}
	return nil
}

func (r *SingersRow) MutationForColumns(columns []string) (string, []string, []interface{}) {
	var values []interface{}
	return "Singers", columns, values
}

func (r *SingersRow) Mutation() (string, []string, []interface{}) {
	return r.MutationForColumns(r.ColumnNames())
}

func (r *SingersRow) Insert() *spanner.Mutation {
	return spanner.Insert(r.Mutation())
}

func (r *SingersRow) InsertOrUpdate() *spanner.Mutation {
	return spanner.InsertOrUpdate(r.Mutation())
}

func (r *SingersRow) Update() *spanner.Mutation {
	return spanner.Update(r.Mutation())
}

func (r *SingersRow) InsertColumns(columns []string) *spanner.Mutation {
	return spanner.Insert(r.MutationForColumns(columns))
}

func (r *SingersRow) InsertOrUpdateColumns(columns []string) *spanner.Mutation {
	return spanner.InsertOrUpdate(r.MutationForColumns(columns))
}

func (r *SingersRow) UpdateColumns(columns []string) *spanner.Mutation {
	return spanner.Update(r.MutationForColumns(columns))
}

func (r *SingersRow) PrimaryKey() SingersPrimaryKey {
	return SingersPrimaryKey{
		SingerId: r.SingerId,
	}
}

type SingersAndAlbumsReadTransaction struct {
	Tx SpannerReadTransaction
}

func (t SingersAndAlbumsReadTransaction) List(
	ctx context.Context,
	query ListQuery,
) *SingersAndAlbumsRowIterator {
	var q strings.Builder
	_, _ = q.WriteString("SELECT ")
	_, _ = q.WriteString("SingerId, ")
	_, _ = q.WriteString("FirstName, ")
	_, _ = q.WriteString("LastName, ")
	_, _ = q.WriteString("SingerInfo, ")
	_, _ = q.WriteString("ARRAY( ")
	_, _ = q.WriteString("SELECT AS STRUCT ")
	_, _ = q.WriteString("SingerId, ")
	_, _ = q.WriteString("AlbumId, ")
	_, _ = q.WriteString("AlbumTitle, ")
	_, _ = q.WriteString("FROM Albums ")
	_, _ = q.WriteString("WHERE ")
	_, _ = q.WriteString("SingerId = Singers.SingerId ")
	_, _ = q.WriteString(") AS Albums, ")
	_, _ = q.WriteString("FROM Singers ")
	if query.Where != nil {
		_, _ = q.WriteString("WHERE (")
		_, _ = q.WriteString(query.Where.SQL())
		_, _ = q.WriteString(") ")
	}
	if len(query.Order) > 0 {
		_, _ = q.WriteString("ORDER BY ")
		for i, order := range query.Order {
			_, _ = q.WriteString(order.SQL())
			if i < len(query.Order)-1 {
				_, _ = q.WriteString(", ")
			}
		}
	}
	_, _ = q.WriteString("LIMIT @limit ")
	_, _ = q.WriteString("OFFSET @offset ")
	stmt := spanner.Statement{
		SQL: q.String(),
		Params: map[string]interface{}{
			"limit":  query.Limit,
			"offset": query.Offset,
		},
	}
	return &SingersAndAlbumsRowIterator{
		RowIterator: t.Tx.Query(ctx, stmt),
	}
}

func (t SingersAndAlbumsReadTransaction) Get(
	ctx context.Context,
	key SingersPrimaryKey,
) (*SingersAndAlbumsRow, error) {
	it := t.List(ctx, ListQuery{
		Where: key.BoolExpr(),
		Limit: 1,
	})
	defer it.Stop()
	row, err := it.Next()
	if err != nil {
		if err == iterator.Done {
			return nil, status.Errorf(codes.NotFound, "not found: %s", key)
		}
		return nil, err
	}
	return row, nil
}

func (t SingersAndAlbumsReadTransaction) BatchGet(
	ctx context.Context,
	keys []SingersPrimaryKey,
) ([]*SingersAndAlbumsRow, error) {
	if len(keys) == 0 {
		return nil, nil
	}
	where := keys[0].BoolExpr()
	for _, key := range keys[1:] {
		where = spansql.LogicalOp{
			Op:  spansql.Or,
			LHS: where,
			RHS: key.BoolExpr(),
		}
	}
	it := t.List(ctx, ListQuery{
		Where: spansql.Paren{Expr: where},
		Limit: int64(len(keys)),
	})
	defer it.Stop()
	foundRows := make(map[SingersPrimaryKey]*SingersAndAlbumsRow, len(keys))
	if err := it.Do(func(row *SingersAndAlbumsRow) error {
		foundRows[row.PrimaryKey()] = row
		return nil
	}); err != nil {
		return nil, err
	}
	rows := make([]*SingersAndAlbumsRow, 0, len(keys))
	for _, key := range keys {
		row, ok := foundRows[key]
		if !ok {
			return nil, status.Errorf(codes.NotFound, "not found: %v", key)
		}
		rows = append(rows, row)
	}
	return rows, nil
}

type SingersAndAlbumsRowIterator struct {
	*spanner.RowIterator
}

func (i *SingersAndAlbumsRowIterator) Next() (*SingersAndAlbumsRow, error) {
	spannerRow, err := i.RowIterator.Next()
	if err != nil {
		return nil, err
	}
	var row SingersAndAlbumsRow
	if err := row.UnmarshalSpannerRow(spannerRow); err != nil {
		return nil, err
	}
	return &row, nil
}

func (i *SingersAndAlbumsRowIterator) Do(f func(row *SingersAndAlbumsRow) error) error {
	return i.RowIterator.Do(func(spannerRow *spanner.Row) error {
		var row SingersAndAlbumsRow
		if err := row.UnmarshalSpannerRow(spannerRow); err != nil {
			return err
		}
		return f(&row)
	})
}

type SingersAndAlbumsRow struct {
	SingerId   int64              `spanner:"SingerId"`
	FirstName  spanner.NullString `spanner:"FirstName"`
	LastName   spanner.NullString `spanner:"LastName"`
	SingerInfo []uint8            `spanner:"SingerInfo"`
	Albums     []*AlbumsRow       `spanner:"Albums"`
}

func (r *SingersAndAlbumsRow) PrimaryKey() SingersPrimaryKey {
	return SingersPrimaryKey{
		SingerId: r.SingerId,
	}
}

func (r *SingersAndAlbumsRow) UnmarshalSpannerRow(row *spanner.Row) error {
	for i := 0; i < row.Size(); i++ {
		switch row.ColumnName(i) {
		case "SingerId":
			if err := row.Column(i, &r.SingerId); err != nil {
				return fmt.Errorf("unmarshal Singers row: SingerId column: %w", err)
			}
		case "FirstName":
			if err := row.Column(i, &r.FirstName); err != nil {
				return fmt.Errorf("unmarshal Singers row: FirstName column: %w", err)
			}
		case "LastName":
			if err := row.Column(i, &r.LastName); err != nil {
				return fmt.Errorf("unmarshal Singers row: LastName column: %w", err)
			}
		case "SingerInfo":
			if err := row.Column(i, &r.SingerInfo); err != nil {
				return fmt.Errorf("unmarshal Singers row: SingerInfo column: %w", err)
			}
		case "Albums":
			if err := row.Column(i, &r.Albums); err != nil {
				return fmt.Errorf("unmarshal Singers interleaved row: Albums column: %w", err)
			}
		default:
			return fmt.Errorf("unmarshal Singers row: unhandled column: %s", row.ColumnName(i))
		}
	}
	return nil
}

type AlbumsReadTransaction struct {
	Tx SpannerReadTransaction
}

func (t AlbumsReadTransaction) Read(
	ctx context.Context,
	keySet spanner.KeySet,
) *AlbumsRowIterator {
	return &AlbumsRowIterator{
		RowIterator: t.Tx.Read(
			ctx,
			"Albums",
			keySet,
			((*AlbumsRow)(nil)).ColumnNames(),
		),
	}
}

func (t AlbumsReadTransaction) Get(
	ctx context.Context,
	key AlbumsPrimaryKey,
) (*AlbumsRow, error) {
	spannerRow, err := t.Tx.ReadRow(
		ctx,
		"Albums",
		key.SpannerKey(),
		((*AlbumsRow)(nil)).ColumnNames(),
	)
	if err != nil {
		return nil, err
	}
	var row AlbumsRow
	if err := row.UnmarshalSpannerRow(spannerRow); err != nil {
		return nil, err
	}
	return &row, nil
}

func (t AlbumsReadTransaction) BatchGet(
	ctx context.Context,
	keys []AlbumsPrimaryKey,
) ([]*AlbumsRow, error) {
	spannerKeys := make([]spanner.KeySet, 0, len(keys))
	for _, key := range keys {
		spannerKeys = append(spannerKeys, key.SpannerKey())
	}
	it := t.Read(ctx, spanner.KeySets(spannerKeys...))
	defer it.Stop()
	foundRows := make(map[AlbumsPrimaryKey]*AlbumsRow, len(keys))
	if err := it.Do(func(row *AlbumsRow) error {
		foundRows[row.PrimaryKey()] = row
		return nil
	}); err != nil {
		return nil, err
	}
	rows := make([]*AlbumsRow, 0, len(keys))
	for _, key := range keys {
		row, ok := foundRows[key]
		if !ok {
			return nil, status.Errorf(codes.NotFound, "not found: %v", key)
		}
		rows = append(rows, row)
	}
	return rows, nil
}

func (t AlbumsReadTransaction) List(
	ctx context.Context,
	query ListQuery,
) *AlbumsRowIterator {
	stmt := spanner.Statement{
		SQL: spansql.Query{
			Select: spansql.Select{
				List: ((*AlbumsRow)(nil)).ColumnExprs(),
				From: []spansql.SelectFrom{
					spansql.SelectFromTable{Table: "Albums"},
				},
				Where: query.Where,
			},
			Order:  query.Order,
			Limit:  spansql.Param("limit"),
			Offset: spansql.Param("offset"),
		}.SQL(),
		Params: map[string]interface{}{
			"limit":  query.Limit,
			"offset": query.Offset,
		},
	}
	return &AlbumsRowIterator{
		RowIterator: t.Tx.Query(ctx, stmt),
	}
}

type AlbumsRowIterator struct {
	*spanner.RowIterator
}

func (i *AlbumsRowIterator) Next() (*AlbumsRow, error) {
	spannerRow, err := i.RowIterator.Next()
	if err != nil {
		return nil, err
	}
	var row AlbumsRow
	if err := row.UnmarshalSpannerRow(spannerRow); err != nil {
		return nil, err
	}
	return &row, nil
}

func (i *AlbumsRowIterator) Do(f func(row *AlbumsRow) error) error {
	return i.RowIterator.Do(func(spannerRow *spanner.Row) error {
		var row AlbumsRow
		if err := row.UnmarshalSpannerRow(spannerRow); err != nil {
			return err
		}
		return f(&row)
	})
}

type AlbumsPrimaryKey struct {
	SingerId int64
	AlbumId  int64
}

func (k AlbumsPrimaryKey) SpannerKey() spanner.Key {
	return spanner.Key{
		k.SingerId,
		k.AlbumId,
	}
}

func (k AlbumsPrimaryKey) SpannerKeySet() spanner.KeySet {
	return k.SpannerKey()
}

func (k AlbumsPrimaryKey) BoolExpr() spansql.BoolExpr {
	b := spansql.BoolExpr(spansql.ComparisonOp{
		Op:  spansql.Eq,
		LHS: spansql.ID("SingerId"),
		RHS: spansql.IntegerLiteral(k.SingerId),
	})
	b = spansql.LogicalOp{
		Op:  spansql.And,
		LHS: b,
		RHS: spansql.ComparisonOp{
			Op:  spansql.Eq,
			LHS: spansql.ID("AlbumId"),
			RHS: spansql.IntegerLiteral(k.AlbumId),
		},
	}
	return spansql.Paren{Expr: b}
}

func (k AlbumsPrimaryKey) QualifiedBoolExpr(prefix spansql.PathExp) spansql.BoolExpr {
	b := spansql.BoolExpr(spansql.ComparisonOp{
		Op:  spansql.Eq,
		LHS: append(prefix, spansql.ID("SingerId")),
		RHS: spansql.IntegerLiteral(k.SingerId),
	})
	b = spansql.LogicalOp{
		Op:  spansql.And,
		LHS: b,
		RHS: spansql.ComparisonOp{
			Op:  spansql.Eq,
			LHS: append(prefix, spansql.ID("AlbumId")),
			RHS: spansql.IntegerLiteral(k.AlbumId),
		},
	}
	return spansql.Paren{Expr: b}
}

type AlbumsPartialKey struct {
	SingerId     int64
	AlbumId      int64
	ValidAlbumId bool
}

func (k AlbumsPartialKey) SpannerKey() spanner.Key {
	n := 1
	if k.ValidAlbumId {
		n++
	}
	result := make(spanner.Key, 0, n)
	result = append(result, k.SingerId)
	if k.ValidAlbumId {
		result = append(result, k.AlbumId)
	}
	return result
}

func (k AlbumsPartialKey) SpannerKeySet() spanner.KeySet {
	return k.SpannerKey()
}

func (k AlbumsPartialKey) BoolExpr() spansql.BoolExpr {
	b := spansql.BoolExpr(spansql.ComparisonOp{
		Op:  spansql.Eq,
		LHS: spansql.ID("SingerId"),
		RHS: spansql.IntegerLiteral(k.SingerId),
	})
	if k.ValidAlbumId {
		b = spansql.LogicalOp{
			Op:  spansql.And,
			LHS: b,
			RHS: spansql.ComparisonOp{
				Op:  spansql.Eq,
				LHS: spansql.ID("AlbumId"),
				RHS: spansql.IntegerLiteral(k.AlbumId),
			},
		}
	}
	return spansql.Paren{Expr: b}
}

func (k AlbumsPartialKey) QualifiedBoolExpr(prefix spansql.PathExp) spansql.BoolExpr {
	b := spansql.BoolExpr(spansql.ComparisonOp{
		Op:  spansql.Eq,
		LHS: append(prefix, spansql.ID("SingerId")),
		RHS: spansql.IntegerLiteral(k.SingerId),
	})
	if k.ValidAlbumId {
		b = spansql.LogicalOp{
			Op:  spansql.And,
			LHS: b,
			RHS: spansql.ComparisonOp{
				Op:  spansql.Eq,
				LHS: append(prefix, spansql.ID("AlbumId")),
				RHS: spansql.IntegerLiteral(k.AlbumId),
			},
		}
	}
	return spansql.Paren{Expr: b}
}

type AlbumsKeyRange struct {
	Start AlbumsPartialKey
	End   AlbumsPartialKey
	Kind  spanner.KeyRangeKind
}

func (k AlbumsKeyRange) SpannerKeySet() spanner.KeySet {
	return spanner.KeyRange{
		Start: k.Start.SpannerKey(),
		End:   k.End.SpannerKey(),
		Kind:  k.Kind,
	}
}

type AlbumsRow struct {
	SingerId   int64              `spanner:"SingerId"`
	AlbumId    int64              `spanner:"AlbumId"`
	AlbumTitle spanner.NullString `spanner:"AlbumTitle"`
}

func (*AlbumsRow) ColumnNames() []string {
	return []string{
		"SingerId",
		"AlbumId",
		"AlbumTitle",
	}
}

func (*AlbumsRow) ColumnIDs() []spansql.ID {
	return []spansql.ID{
		"SingerId",
		"AlbumId",
		"AlbumTitle",
	}
}

func (*AlbumsRow) ColumnExprs() []spansql.Expr {
	return []spansql.Expr{
		spansql.ID("SingerId"),
		spansql.ID("AlbumId"),
		spansql.ID("AlbumTitle"),
	}
}

func (r *AlbumsRow) Validate() error {
	return nil
}

func (r *AlbumsRow) UnmarshalSpannerRow(row *spanner.Row) error {
	for i := 0; i < row.Size(); i++ {
		switch row.ColumnName(i) {
		case "SingerId":
			if err := row.Column(i, &r.SingerId); err != nil {
				return fmt.Errorf("unmarshal Albums row: SingerId column: %w", err)
			}
		case "AlbumId":
			if err := row.Column(i, &r.AlbumId); err != nil {
				return fmt.Errorf("unmarshal Albums row: AlbumId column: %w", err)
			}
		case "AlbumTitle":
			if err := row.Column(i, &r.AlbumTitle); err != nil {
				return fmt.Errorf("unmarshal Albums row: AlbumTitle column: %w", err)
			}
		default:
			return fmt.Errorf("unmarshal Albums row: unhandled column: %s", row.ColumnName(i))
		}
	}
	return nil
}

func (r *AlbumsRow) MutationForColumns(columns []string) (string, []string, []interface{}) {
	var values []interface{}
	return "Albums", columns, values
}

func (r *AlbumsRow) Mutation() (string, []string, []interface{}) {
	return r.MutationForColumns(r.ColumnNames())
}

func (r *AlbumsRow) Insert() *spanner.Mutation {
	return spanner.Insert(r.Mutation())
}

func (r *AlbumsRow) InsertOrUpdate() *spanner.Mutation {
	return spanner.InsertOrUpdate(r.Mutation())
}

func (r *AlbumsRow) Update() *spanner.Mutation {
	return spanner.Update(r.Mutation())
}

func (r *AlbumsRow) InsertColumns(columns []string) *spanner.Mutation {
	return spanner.Insert(r.MutationForColumns(columns))
}

func (r *AlbumsRow) InsertOrUpdateColumns(columns []string) *spanner.Mutation {
	return spanner.InsertOrUpdate(r.MutationForColumns(columns))
}

func (r *AlbumsRow) UpdateColumns(columns []string) *spanner.Mutation {
	return spanner.Update(r.MutationForColumns(columns))
}

func (r *AlbumsRow) PrimaryKey() AlbumsPrimaryKey {
	return AlbumsPrimaryKey{
		SingerId: r.SingerId,
		AlbumId:  r.AlbumId,
	}
}

type AlbumsAndSongsReadTransaction struct {
	Tx SpannerReadTransaction
}

func (t AlbumsAndSongsReadTransaction) List(
	ctx context.Context,
	query ListQuery,
) *AlbumsAndSongsRowIterator {
	var q strings.Builder
	_, _ = q.WriteString("SELECT ")
	_, _ = q.WriteString("SingerId, ")
	_, _ = q.WriteString("AlbumId, ")
	_, _ = q.WriteString("AlbumTitle, ")
	_, _ = q.WriteString("ARRAY( ")
	_, _ = q.WriteString("SELECT AS STRUCT ")
	_, _ = q.WriteString("SingerId, ")
	_, _ = q.WriteString("AlbumId, ")
	_, _ = q.WriteString("TrackId, ")
	_, _ = q.WriteString("SongName, ")
	_, _ = q.WriteString("FROM Songs ")
	_, _ = q.WriteString("WHERE ")
	_, _ = q.WriteString("SingerId = Albums.SingerId ")
	_, _ = q.WriteString("AND ")
	_, _ = q.WriteString("AlbumId = Albums.AlbumId ")
	_, _ = q.WriteString(") AS Songs, ")
	_, _ = q.WriteString("FROM Albums ")
	if query.Where != nil {
		_, _ = q.WriteString("WHERE (")
		_, _ = q.WriteString(query.Where.SQL())
		_, _ = q.WriteString(") ")
	}
	if len(query.Order) > 0 {
		_, _ = q.WriteString("ORDER BY ")
		for i, order := range query.Order {
			_, _ = q.WriteString(order.SQL())
			if i < len(query.Order)-1 {
				_, _ = q.WriteString(", ")
			}
		}
	}
	_, _ = q.WriteString("LIMIT @limit ")
	_, _ = q.WriteString("OFFSET @offset ")
	stmt := spanner.Statement{
		SQL: q.String(),
		Params: map[string]interface{}{
			"limit":  query.Limit,
			"offset": query.Offset,
		},
	}
	return &AlbumsAndSongsRowIterator{
		RowIterator: t.Tx.Query(ctx, stmt),
	}
}

func (t AlbumsAndSongsReadTransaction) Get(
	ctx context.Context,
	key AlbumsPrimaryKey,
) (*AlbumsAndSongsRow, error) {
	it := t.List(ctx, ListQuery{
		Where: key.BoolExpr(),
		Limit: 1,
	})
	defer it.Stop()
	row, err := it.Next()
	if err != nil {
		if err == iterator.Done {
			return nil, status.Errorf(codes.NotFound, "not found: %s", key)
		}
		return nil, err
	}
	return row, nil
}

func (t AlbumsAndSongsReadTransaction) BatchGet(
	ctx context.Context,
	keys []AlbumsPrimaryKey,
) ([]*AlbumsAndSongsRow, error) {
	if len(keys) == 0 {
		return nil, nil
	}
	where := keys[0].BoolExpr()
	for _, key := range keys[1:] {
		where = spansql.LogicalOp{
			Op:  spansql.Or,
			LHS: where,
			RHS: key.BoolExpr(),
		}
	}
	it := t.List(ctx, ListQuery{
		Where: spansql.Paren{Expr: where},
		Limit: int64(len(keys)),
	})
	defer it.Stop()
	foundRows := make(map[AlbumsPrimaryKey]*AlbumsAndSongsRow, len(keys))
	if err := it.Do(func(row *AlbumsAndSongsRow) error {
		foundRows[row.PrimaryKey()] = row
		return nil
	}); err != nil {
		return nil, err
	}
	rows := make([]*AlbumsAndSongsRow, 0, len(keys))
	for _, key := range keys {
		row, ok := foundRows[key]
		if !ok {
			return nil, status.Errorf(codes.NotFound, "not found: %v", key)
		}
		rows = append(rows, row)
	}
	return rows, nil
}

type AlbumsAndSongsRowIterator struct {
	*spanner.RowIterator
}

func (i *AlbumsAndSongsRowIterator) Next() (*AlbumsAndSongsRow, error) {
	spannerRow, err := i.RowIterator.Next()
	if err != nil {
		return nil, err
	}
	var row AlbumsAndSongsRow
	if err := row.UnmarshalSpannerRow(spannerRow); err != nil {
		return nil, err
	}
	return &row, nil
}

func (i *AlbumsAndSongsRowIterator) Do(f func(row *AlbumsAndSongsRow) error) error {
	return i.RowIterator.Do(func(spannerRow *spanner.Row) error {
		var row AlbumsAndSongsRow
		if err := row.UnmarshalSpannerRow(spannerRow); err != nil {
			return err
		}
		return f(&row)
	})
}

type AlbumsAndSongsRow struct {
	SingerId   int64              `spanner:"SingerId"`
	AlbumId    int64              `spanner:"AlbumId"`
	AlbumTitle spanner.NullString `spanner:"AlbumTitle"`
	Songs      []*SongsRow        `spanner:"Songs"`
}

func (r *AlbumsAndSongsRow) PrimaryKey() AlbumsPrimaryKey {
	return AlbumsPrimaryKey{
		SingerId: r.SingerId,
		AlbumId:  r.AlbumId,
	}
}

func (r *AlbumsAndSongsRow) UnmarshalSpannerRow(row *spanner.Row) error {
	for i := 0; i < row.Size(); i++ {
		switch row.ColumnName(i) {
		case "SingerId":
			if err := row.Column(i, &r.SingerId); err != nil {
				return fmt.Errorf("unmarshal Albums row: SingerId column: %w", err)
			}
		case "AlbumId":
			if err := row.Column(i, &r.AlbumId); err != nil {
				return fmt.Errorf("unmarshal Albums row: AlbumId column: %w", err)
			}
		case "AlbumTitle":
			if err := row.Column(i, &r.AlbumTitle); err != nil {
				return fmt.Errorf("unmarshal Albums row: AlbumTitle column: %w", err)
			}
		case "Songs":
			if err := row.Column(i, &r.Songs); err != nil {
				return fmt.Errorf("unmarshal Albums interleaved row: Songs column: %w", err)
			}
		default:
			return fmt.Errorf("unmarshal Albums row: unhandled column: %s", row.ColumnName(i))
		}
	}
	return nil
}

type SongsReadTransaction struct {
	Tx SpannerReadTransaction
}

func (t SongsReadTransaction) Read(
	ctx context.Context,
	keySet spanner.KeySet,
) *SongsRowIterator {
	return &SongsRowIterator{
		RowIterator: t.Tx.Read(
			ctx,
			"Songs",
			keySet,
			((*SongsRow)(nil)).ColumnNames(),
		),
	}
}

func (t SongsReadTransaction) Get(
	ctx context.Context,
	key SongsPrimaryKey,
) (*SongsRow, error) {
	spannerRow, err := t.Tx.ReadRow(
		ctx,
		"Songs",
		key.SpannerKey(),
		((*SongsRow)(nil)).ColumnNames(),
	)
	if err != nil {
		return nil, err
	}
	var row SongsRow
	if err := row.UnmarshalSpannerRow(spannerRow); err != nil {
		return nil, err
	}
	return &row, nil
}

func (t SongsReadTransaction) BatchGet(
	ctx context.Context,
	keys []SongsPrimaryKey,
) ([]*SongsRow, error) {
	spannerKeys := make([]spanner.KeySet, 0, len(keys))
	for _, key := range keys {
		spannerKeys = append(spannerKeys, key.SpannerKey())
	}
	it := t.Read(ctx, spanner.KeySets(spannerKeys...))
	defer it.Stop()
	foundRows := make(map[SongsPrimaryKey]*SongsRow, len(keys))
	if err := it.Do(func(row *SongsRow) error {
		foundRows[row.PrimaryKey()] = row
		return nil
	}); err != nil {
		return nil, err
	}
	rows := make([]*SongsRow, 0, len(keys))
	for _, key := range keys {
		row, ok := foundRows[key]
		if !ok {
			return nil, status.Errorf(codes.NotFound, "not found: %v", key)
		}
		rows = append(rows, row)
	}
	return rows, nil
}

func (t SongsReadTransaction) List(
	ctx context.Context,
	query ListQuery,
) *SongsRowIterator {
	stmt := spanner.Statement{
		SQL: spansql.Query{
			Select: spansql.Select{
				List: ((*SongsRow)(nil)).ColumnExprs(),
				From: []spansql.SelectFrom{
					spansql.SelectFromTable{Table: "Songs"},
				},
				Where: query.Where,
			},
			Order:  query.Order,
			Limit:  spansql.Param("limit"),
			Offset: spansql.Param("offset"),
		}.SQL(),
		Params: map[string]interface{}{
			"limit":  query.Limit,
			"offset": query.Offset,
		},
	}
	return &SongsRowIterator{
		RowIterator: t.Tx.Query(ctx, stmt),
	}
}

type SongsRowIterator struct {
	*spanner.RowIterator
}

func (i *SongsRowIterator) Next() (*SongsRow, error) {
	spannerRow, err := i.RowIterator.Next()
	if err != nil {
		return nil, err
	}
	var row SongsRow
	if err := row.UnmarshalSpannerRow(spannerRow); err != nil {
		return nil, err
	}
	return &row, nil
}

func (i *SongsRowIterator) Do(f func(row *SongsRow) error) error {
	return i.RowIterator.Do(func(spannerRow *spanner.Row) error {
		var row SongsRow
		if err := row.UnmarshalSpannerRow(spannerRow); err != nil {
			return err
		}
		return f(&row)
	})
}

type SongsPrimaryKey struct {
	SingerId int64
	AlbumId  int64
	TrackId  int64
}

func (k SongsPrimaryKey) SpannerKey() spanner.Key {
	return spanner.Key{
		k.SingerId,
		k.AlbumId,
		k.TrackId,
	}
}

func (k SongsPrimaryKey) SpannerKeySet() spanner.KeySet {
	return k.SpannerKey()
}

func (k SongsPrimaryKey) BoolExpr() spansql.BoolExpr {
	b := spansql.BoolExpr(spansql.ComparisonOp{
		Op:  spansql.Eq,
		LHS: spansql.ID("SingerId"),
		RHS: spansql.IntegerLiteral(k.SingerId),
	})
	b = spansql.LogicalOp{
		Op:  spansql.And,
		LHS: b,
		RHS: spansql.ComparisonOp{
			Op:  spansql.Eq,
			LHS: spansql.ID("AlbumId"),
			RHS: spansql.IntegerLiteral(k.AlbumId),
		},
	}
	b = spansql.LogicalOp{
		Op:  spansql.And,
		LHS: b,
		RHS: spansql.ComparisonOp{
			Op:  spansql.Eq,
			LHS: spansql.ID("TrackId"),
			RHS: spansql.IntegerLiteral(k.TrackId),
		},
	}
	return spansql.Paren{Expr: b}
}

func (k SongsPrimaryKey) QualifiedBoolExpr(prefix spansql.PathExp) spansql.BoolExpr {
	b := spansql.BoolExpr(spansql.ComparisonOp{
		Op:  spansql.Eq,
		LHS: append(prefix, spansql.ID("SingerId")),
		RHS: spansql.IntegerLiteral(k.SingerId),
	})
	b = spansql.LogicalOp{
		Op:  spansql.And,
		LHS: b,
		RHS: spansql.ComparisonOp{
			Op:  spansql.Eq,
			LHS: append(prefix, spansql.ID("AlbumId")),
			RHS: spansql.IntegerLiteral(k.AlbumId),
		},
	}
	b = spansql.LogicalOp{
		Op:  spansql.And,
		LHS: b,
		RHS: spansql.ComparisonOp{
			Op:  spansql.Eq,
			LHS: append(prefix, spansql.ID("TrackId")),
			RHS: spansql.IntegerLiteral(k.TrackId),
		},
	}
	return spansql.Paren{Expr: b}
}

type SongsPartialKey struct {
	SingerId     int64
	AlbumId      int64
	ValidAlbumId bool
	TrackId      int64
	ValidTrackId bool
}

func (k SongsPartialKey) SpannerKey() spanner.Key {
	n := 1
	if k.ValidAlbumId {
		n++
		if k.ValidTrackId {
			n++
		}
	}
	result := make(spanner.Key, 0, n)
	result = append(result, k.SingerId)
	if k.ValidAlbumId {
		result = append(result, k.AlbumId)
		if k.ValidTrackId {
			result = append(result, k.TrackId)
		}
	}
	return result
}

func (k SongsPartialKey) SpannerKeySet() spanner.KeySet {
	return k.SpannerKey()
}

func (k SongsPartialKey) BoolExpr() spansql.BoolExpr {
	b := spansql.BoolExpr(spansql.ComparisonOp{
		Op:  spansql.Eq,
		LHS: spansql.ID("SingerId"),
		RHS: spansql.IntegerLiteral(k.SingerId),
	})
	if k.ValidAlbumId {
		b = spansql.LogicalOp{
			Op:  spansql.And,
			LHS: b,
			RHS: spansql.ComparisonOp{
				Op:  spansql.Eq,
				LHS: spansql.ID("AlbumId"),
				RHS: spansql.IntegerLiteral(k.AlbumId),
			},
		}
		if k.ValidTrackId {
			b = spansql.LogicalOp{
				Op:  spansql.And,
				LHS: b,
				RHS: spansql.ComparisonOp{
					Op:  spansql.Eq,
					LHS: spansql.ID("TrackId"),
					RHS: spansql.IntegerLiteral(k.TrackId),
				},
			}
		}
	}
	return spansql.Paren{Expr: b}
}

func (k SongsPartialKey) QualifiedBoolExpr(prefix spansql.PathExp) spansql.BoolExpr {
	b := spansql.BoolExpr(spansql.ComparisonOp{
		Op:  spansql.Eq,
		LHS: append(prefix, spansql.ID("SingerId")),
		RHS: spansql.IntegerLiteral(k.SingerId),
	})
	if k.ValidAlbumId {
		b = spansql.LogicalOp{
			Op:  spansql.And,
			LHS: b,
			RHS: spansql.ComparisonOp{
				Op:  spansql.Eq,
				LHS: append(prefix, spansql.ID("AlbumId")),
				RHS: spansql.IntegerLiteral(k.AlbumId),
			},
		}
		if k.ValidTrackId {
			b = spansql.LogicalOp{
				Op:  spansql.And,
				LHS: b,
				RHS: spansql.ComparisonOp{
					Op:  spansql.Eq,
					LHS: append(prefix, spansql.ID("TrackId")),
					RHS: spansql.IntegerLiteral(k.TrackId),
				},
			}
		}
	}
	return spansql.Paren{Expr: b}
}

type SongsKeyRange struct {
	Start SongsPartialKey
	End   SongsPartialKey
	Kind  spanner.KeyRangeKind
}

func (k SongsKeyRange) SpannerKeySet() spanner.KeySet {
	return spanner.KeyRange{
		Start: k.Start.SpannerKey(),
		End:   k.End.SpannerKey(),
		Kind:  k.Kind,
	}
}

type SongsRow struct {
	SingerId int64              `spanner:"SingerId"`
	AlbumId  int64              `spanner:"AlbumId"`
	TrackId  int64              `spanner:"TrackId"`
	SongName spanner.NullString `spanner:"SongName"`
}

func (*SongsRow) ColumnNames() []string {
	return []string{
		"SingerId",
		"AlbumId",
		"TrackId",
		"SongName",
	}
}

func (*SongsRow) ColumnIDs() []spansql.ID {
	return []spansql.ID{
		"SingerId",
		"AlbumId",
		"TrackId",
		"SongName",
	}
}

func (*SongsRow) ColumnExprs() []spansql.Expr {
	return []spansql.Expr{
		spansql.ID("SingerId"),
		spansql.ID("AlbumId"),
		spansql.ID("TrackId"),
		spansql.ID("SongName"),
	}
}

func (r *SongsRow) Validate() error {
	return nil
}

func (r *SongsRow) UnmarshalSpannerRow(row *spanner.Row) error {
	for i := 0; i < row.Size(); i++ {
		switch row.ColumnName(i) {
		case "SingerId":
			if err := row.Column(i, &r.SingerId); err != nil {
				return fmt.Errorf("unmarshal Songs row: SingerId column: %w", err)
			}
		case "AlbumId":
			if err := row.Column(i, &r.AlbumId); err != nil {
				return fmt.Errorf("unmarshal Songs row: AlbumId column: %w", err)
			}
		case "TrackId":
			if err := row.Column(i, &r.TrackId); err != nil {
				return fmt.Errorf("unmarshal Songs row: TrackId column: %w", err)
			}
		case "SongName":
			if err := row.Column(i, &r.SongName); err != nil {
				return fmt.Errorf("unmarshal Songs row: SongName column: %w", err)
			}
		default:
			return fmt.Errorf("unmarshal Songs row: unhandled column: %s", row.ColumnName(i))
		}
	}
	return nil
}

func (r *SongsRow) MutationForColumns(columns []string) (string, []string, []interface{}) {
	var values []interface{}
	return "Songs", columns, values
}

func (r *SongsRow) Mutation() (string, []string, []interface{}) {
	return r.MutationForColumns(r.ColumnNames())
}

func (r *SongsRow) Insert() *spanner.Mutation {
	return spanner.Insert(r.Mutation())
}

func (r *SongsRow) InsertOrUpdate() *spanner.Mutation {
	return spanner.InsertOrUpdate(r.Mutation())
}

func (r *SongsRow) Update() *spanner.Mutation {
	return spanner.Update(r.Mutation())
}

func (r *SongsRow) InsertColumns(columns []string) *spanner.Mutation {
	return spanner.Insert(r.MutationForColumns(columns))
}

func (r *SongsRow) InsertOrUpdateColumns(columns []string) *spanner.Mutation {
	return spanner.InsertOrUpdate(r.MutationForColumns(columns))
}

func (r *SongsRow) UpdateColumns(columns []string) *spanner.Mutation {
	return spanner.Update(r.MutationForColumns(columns))
}

func (r *SongsRow) PrimaryKey() SongsPrimaryKey {
	return SongsPrimaryKey{
		SingerId: r.SingerId,
		AlbumId:  r.AlbumId,
		TrackId:  r.TrackId,
	}
}

type ListQuery struct {
	Where  spansql.BoolExpr
	Order  []spansql.Order
	Limit  int64
	Offset int64
}

type SpannerReadTransaction interface {
	Read(ctx context.Context, table string, keys spanner.KeySet, columns []string) *spanner.RowIterator
	ReadRow(ctx context.Context, table string, key spanner.Key, columns []string) (*spanner.Row, error)
	Query(ctx context.Context, statement spanner.Statement) *spanner.RowIterator
}
