package freightdb

// Code generated by aip-spanner-go. DO NOT EDIT.

import (
	"context"
	"fmt"
	"strings"
	"time"

	"cloud.google.com/go/spanner"
	"cloud.google.com/go/spanner/spansql"
	"google.golang.org/api/iterator"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

type ShippersReadTransaction struct {
	Tx SpannerReadTransaction
}

func Shippers(tx SpannerReadTransaction) ShippersReadTransaction {
	return ShippersReadTransaction{Tx: tx}
}

func (t ShippersReadTransaction) Read(
	ctx context.Context,
	keySet spanner.KeySet,
) *ShippersRowIterator {
	return &ShippersRowIterator{
		RowIterator: t.Tx.Read(
			ctx,
			"shippers",
			keySet,
			((*ShippersRow)(nil)).ColumnNames(),
		),
	}
}

func (t ShippersReadTransaction) Get(
	ctx context.Context,
	key ShippersKey,
) (*ShippersRow, error) {
	spannerRow, err := t.Tx.ReadRow(
		ctx,
		"shippers",
		key.SpannerKey(),
		((*ShippersRow)(nil)).ColumnNames(),
	)
	if err != nil {
		return nil, err
	}
	var row ShippersRow
	if err := row.UnmarshalSpannerRow(spannerRow); err != nil {
		return nil, err
	}
	return &row, nil
}

func (t ShippersReadTransaction) BatchGet(
	ctx context.Context,
	keys []ShippersKey,
) (map[ShippersKey]*ShippersRow, error) {
	spannerKeys := make([]spanner.KeySet, 0, len(keys))
	for _, key := range keys {
		spannerKeys = append(spannerKeys, key.SpannerKey())
	}
	foundRows := make(map[ShippersKey]*ShippersRow, len(keys))
	if err := t.Read(ctx, spanner.KeySets(spannerKeys...)).Do(func(row *ShippersRow) error {
		foundRows[row.PrimaryKey()] = row
		return nil
	}); err != nil {
		return nil, err
	}
	return foundRows, nil
}

func (t ShippersReadTransaction) List(
	ctx context.Context,
	query ListQuery,
) *ShippersRowIterator {
	stmt := spanner.Statement{
		SQL: spansql.Query{
			Select: spansql.Select{
				List: ((*ShippersRow)(nil)).ColumnExprs(),
				From: []spansql.SelectFrom{
					spansql.SelectFromTable{Table: "shippers"},
				},
				Where: query.Where,
			},
			Order:  query.Order,
			Limit:  spansql.Param("limit"),
			Offset: spansql.Param("offset"),
		}.SQL(),
		Params: map[string]interface{}{
			"limit":  query.Limit,
			"offset": query.Offset,
		},
	}
	return &ShippersRowIterator{
		RowIterator: t.Tx.Query(ctx, stmt),
	}
}

type ShippersRowIterator struct {
	*spanner.RowIterator
}

func (i *ShippersRowIterator) Next() (*ShippersRow, error) {
	spannerRow, err := i.RowIterator.Next()
	if err != nil {
		return nil, err
	}
	var row ShippersRow
	if err := row.UnmarshalSpannerRow(spannerRow); err != nil {
		return nil, err
	}
	return &row, nil
}

func (i *ShippersRowIterator) Do(f func(row *ShippersRow) error) error {
	return i.RowIterator.Do(func(spannerRow *spanner.Row) error {
		var row ShippersRow
		if err := row.UnmarshalSpannerRow(spannerRow); err != nil {
			return err
		}
		return f(&row)
	})
}

type ShippersKey struct {
	ShipperId string
}

func (k ShippersKey) SpannerKey() spanner.Key {
	return spanner.Key{
		k.ShipperId,
	}
}

func (k ShippersKey) SpannerKeySet() spanner.KeySet {
	return k.SpannerKey()
}

func (k ShippersKey) Delete() *spanner.Mutation {
	return spanner.Delete("shippers", k.SpannerKey())
}

func (k ShippersKey) BoolExpr() spansql.BoolExpr {
	b := spansql.BoolExpr(spansql.ComparisonOp{
		Op:  spansql.Eq,
		LHS: spansql.ID("shipper_id"),
		RHS: spansql.StringLiteral(k.ShipperId),
	})
	return spansql.Paren{Expr: b}
}

func (k ShippersKey) QualifiedBoolExpr(prefix spansql.PathExp) spansql.BoolExpr {
	b := spansql.BoolExpr(spansql.ComparisonOp{
		Op:  spansql.Eq,
		LHS: append(prefix, spansql.ID("shipper_id")),
		RHS: spansql.StringLiteral(k.ShipperId),
	})
	return spansql.Paren{Expr: b}
}

type ShippersKeyPrefix struct {
	ShipperId string
}

func (k ShippersKeyPrefix) SpannerKey() spanner.Key {
	return spanner.Key{k.ShipperId}
}

func (k ShippersKeyPrefix) Delete() *spanner.Mutation {
	return spanner.Delete("shippers", k.SpannerKey())
}

func (k ShippersKeyPrefix) BoolExpr() spansql.BoolExpr {
	b := spansql.BoolExpr(spansql.ComparisonOp{
		Op:  spansql.Eq,
		LHS: spansql.ID("shipper_id"),
		RHS: spansql.StringLiteral(k.ShipperId),
	})
	return spansql.Paren{Expr: b}
}

func (k ShippersKeyPrefix) QualifiedBoolExpr(prefix spansql.PathExp) spansql.BoolExpr {
	b := spansql.BoolExpr(spansql.ComparisonOp{
		Op:  spansql.Eq,
		LHS: append(prefix, spansql.ID("shipper_id")),
		RHS: spansql.StringLiteral(k.ShipperId),
	})
	return spansql.Paren{Expr: b}
}

type ShippersKeyRange struct {
	Start ShippersKeyPrefix
	End   ShippersKeyPrefix
	Kind  spanner.KeyRangeKind
}

func (k ShippersKeyRange) SpannerKeySet() spanner.KeySet {
	return spanner.KeyRange{
		Start: k.Start.SpannerKey(),
		End:   k.End.SpannerKey(),
		Kind:  k.Kind,
	}
}

type ShippersRow struct {
	ShipperId  string           `spanner:"shipper_id"`
	CreateTime time.Time        `spanner:"create_time"`
	UpdateTime time.Time        `spanner:"update_time"`
	DeleteTime spanner.NullTime `spanner:"delete_time"`
}

func (*ShippersRow) ColumnNames() []string {
	return []string{
		"shipper_id",
		"create_time",
		"update_time",
		"delete_time",
	}
}

func (*ShippersRow) ColumnIDs() []spansql.ID {
	return []spansql.ID{
		"shipper_id",
		"create_time",
		"update_time",
		"delete_time",
	}
}

func (*ShippersRow) ColumnExprs() []spansql.Expr {
	return []spansql.Expr{
		spansql.ID("shipper_id"),
		spansql.ID("create_time"),
		spansql.ID("update_time"),
		spansql.ID("delete_time"),
	}
}

func (r *ShippersRow) Validate() error {
	if len(r.ShipperId) > 63 {
		return fmt.Errorf("column shipper_id length > 63")
	}
	return nil
}

func (r *ShippersRow) UnmarshalSpannerRow(row *spanner.Row) error {
	for i := 0; i < row.Size(); i++ {
		switch row.ColumnName(i) {
		case "shipper_id":
			if err := row.Column(i, &r.ShipperId); err != nil {
				return fmt.Errorf("unmarshal shippers row: shipper_id column: %w", err)
			}
		case "create_time":
			if err := row.Column(i, &r.CreateTime); err != nil {
				return fmt.Errorf("unmarshal shippers row: create_time column: %w", err)
			}
		case "update_time":
			if err := row.Column(i, &r.UpdateTime); err != nil {
				return fmt.Errorf("unmarshal shippers row: update_time column: %w", err)
			}
		case "delete_time":
			if err := row.Column(i, &r.DeleteTime); err != nil {
				return fmt.Errorf("unmarshal shippers row: delete_time column: %w", err)
			}
		default:
			return fmt.Errorf("unmarshal shippers row: unhandled column: %s", row.ColumnName(i))
		}
	}
	return nil
}

func (r *ShippersRow) Insert() *spanner.Mutation {
	return spanner.Insert(r.Mutation())
}

func (r *ShippersRow) InsertOrUpdate() *spanner.Mutation {
	return spanner.InsertOrUpdate(r.Mutation())
}

func (r *ShippersRow) Update() *spanner.Mutation {
	return spanner.Update(r.Mutation())
}

func (r *ShippersRow) InsertColumns(columns []string) *spanner.Mutation {
	return spanner.Insert(r.MutationForColumns(columns))
}

func (r *ShippersRow) InsertOrUpdateColumns(columns []string) *spanner.Mutation {
	return spanner.InsertOrUpdate(r.MutationForColumns(columns))
}

func (r *ShippersRow) UpdateColumns(columns []string) *spanner.Mutation {
	return spanner.Update(r.MutationForColumns(columns))
}

func (r *ShippersRow) Mutation() (string, []string, []interface{}) {
	return "shippers", r.ColumnNames(), []interface{}{
		r.ShipperId,
		r.CreateTime,
		r.UpdateTime,
		r.DeleteTime,
	}
}

func (r *ShippersRow) MutationForColumns(columns []string) (string, []string, []interface{}) {
	if len(columns) == 0 {
		columns = r.ColumnNames()
	}
	values := make([]interface{}, 0, len(columns))
	for _, column := range columns {
		switch column {
		case "shipper_id":
			values = append(values, r.ShipperId)
		case "create_time":
			values = append(values, r.CreateTime)
		case "update_time":
			values = append(values, r.UpdateTime)
		case "delete_time":
			values = append(values, r.DeleteTime)
		default:
			panic(fmt.Errorf("table shippers does not have column %s", column))
		}
	}
	return "shippers", columns, values
}

func (r *ShippersRow) PrimaryKey() ShippersKey {
	return ShippersKey{
		ShipperId: r.ShipperId,
	}
}

type SitesReadTransaction struct {
	Tx SpannerReadTransaction
}

func Sites(tx SpannerReadTransaction) SitesReadTransaction {
	return SitesReadTransaction{Tx: tx}
}

func (t SitesReadTransaction) Read(
	ctx context.Context,
	keySet spanner.KeySet,
) *SitesRowIterator {
	return &SitesRowIterator{
		RowIterator: t.Tx.Read(
			ctx,
			"sites",
			keySet,
			((*SitesRow)(nil)).ColumnNames(),
		),
	}
}

func (t SitesReadTransaction) Get(
	ctx context.Context,
	key SitesKey,
) (*SitesRow, error) {
	spannerRow, err := t.Tx.ReadRow(
		ctx,
		"sites",
		key.SpannerKey(),
		((*SitesRow)(nil)).ColumnNames(),
	)
	if err != nil {
		return nil, err
	}
	var row SitesRow
	if err := row.UnmarshalSpannerRow(spannerRow); err != nil {
		return nil, err
	}
	return &row, nil
}

func (t SitesReadTransaction) BatchGet(
	ctx context.Context,
	keys []SitesKey,
) (map[SitesKey]*SitesRow, error) {
	spannerKeys := make([]spanner.KeySet, 0, len(keys))
	for _, key := range keys {
		spannerKeys = append(spannerKeys, key.SpannerKey())
	}
	foundRows := make(map[SitesKey]*SitesRow, len(keys))
	if err := t.Read(ctx, spanner.KeySets(spannerKeys...)).Do(func(row *SitesRow) error {
		foundRows[row.PrimaryKey()] = row
		return nil
	}); err != nil {
		return nil, err
	}
	return foundRows, nil
}

func (t SitesReadTransaction) List(
	ctx context.Context,
	query ListQuery,
) *SitesRowIterator {
	stmt := spanner.Statement{
		SQL: spansql.Query{
			Select: spansql.Select{
				List: ((*SitesRow)(nil)).ColumnExprs(),
				From: []spansql.SelectFrom{
					spansql.SelectFromTable{Table: "sites"},
				},
				Where: query.Where,
			},
			Order:  query.Order,
			Limit:  spansql.Param("limit"),
			Offset: spansql.Param("offset"),
		}.SQL(),
		Params: map[string]interface{}{
			"limit":  query.Limit,
			"offset": query.Offset,
		},
	}
	return &SitesRowIterator{
		RowIterator: t.Tx.Query(ctx, stmt),
	}
}

type SitesRowIterator struct {
	*spanner.RowIterator
}

func (i *SitesRowIterator) Next() (*SitesRow, error) {
	spannerRow, err := i.RowIterator.Next()
	if err != nil {
		return nil, err
	}
	var row SitesRow
	if err := row.UnmarshalSpannerRow(spannerRow); err != nil {
		return nil, err
	}
	return &row, nil
}

func (i *SitesRowIterator) Do(f func(row *SitesRow) error) error {
	return i.RowIterator.Do(func(spannerRow *spanner.Row) error {
		var row SitesRow
		if err := row.UnmarshalSpannerRow(spannerRow); err != nil {
			return err
		}
		return f(&row)
	})
}

type SitesKey struct {
	ShipperId string
	SiteId    string
}

func (k SitesKey) SpannerKey() spanner.Key {
	return spanner.Key{
		k.ShipperId,
		k.SiteId,
	}
}

func (k SitesKey) SpannerKeySet() spanner.KeySet {
	return k.SpannerKey()
}

func (k SitesKey) Delete() *spanner.Mutation {
	return spanner.Delete("sites", k.SpannerKey())
}

func (k SitesKey) BoolExpr() spansql.BoolExpr {
	b := spansql.BoolExpr(spansql.ComparisonOp{
		Op:  spansql.Eq,
		LHS: spansql.ID("shipper_id"),
		RHS: spansql.StringLiteral(k.ShipperId),
	})
	b = spansql.LogicalOp{
		Op:  spansql.And,
		LHS: b,
		RHS: spansql.ComparisonOp{
			Op:  spansql.Eq,
			LHS: spansql.ID("site_id"),
			RHS: spansql.StringLiteral(k.SiteId),
		},
	}
	return spansql.Paren{Expr: b}
}

func (k SitesKey) QualifiedBoolExpr(prefix spansql.PathExp) spansql.BoolExpr {
	b := spansql.BoolExpr(spansql.ComparisonOp{
		Op:  spansql.Eq,
		LHS: append(prefix, spansql.ID("shipper_id")),
		RHS: spansql.StringLiteral(k.ShipperId),
	})
	b = spansql.LogicalOp{
		Op:  spansql.And,
		LHS: b,
		RHS: spansql.ComparisonOp{
			Op:  spansql.Eq,
			LHS: append(prefix, spansql.ID("site_id")),
			RHS: spansql.StringLiteral(k.SiteId),
		},
	}
	return spansql.Paren{Expr: b}
}

type SitesKeyPrefix struct {
	ShipperId   string
	SiteId      string
	ValidSiteId bool
}

func (k SitesKeyPrefix) SpannerKey() spanner.Key {
	n := 1
	if k.ValidSiteId {
		n++
	}
	result := make(spanner.Key, 0, n)
	result = append(result, k.ShipperId)
	if k.ValidSiteId {
		result = append(result, k.SiteId)
	}
	return result
}

func (k SitesKeyPrefix) SpannerKeySet() spanner.KeySet {
	return k.SpannerKey()
}

func (k SitesKeyPrefix) Delete() *spanner.Mutation {
	return spanner.Delete("sites", k.SpannerKey())
}

func (k SitesKeyPrefix) BoolExpr() spansql.BoolExpr {
	b := spansql.BoolExpr(spansql.ComparisonOp{
		Op:  spansql.Eq,
		LHS: spansql.ID("shipper_id"),
		RHS: spansql.StringLiteral(k.ShipperId),
	})
	if k.ValidSiteId {
		b = spansql.LogicalOp{
			Op:  spansql.And,
			LHS: b,
			RHS: spansql.ComparisonOp{
				Op:  spansql.Eq,
				LHS: spansql.ID("site_id"),
				RHS: spansql.StringLiteral(k.SiteId),
			},
		}
	}
	return spansql.Paren{Expr: b}
}

func (k SitesKeyPrefix) QualifiedBoolExpr(prefix spansql.PathExp) spansql.BoolExpr {
	b := spansql.BoolExpr(spansql.ComparisonOp{
		Op:  spansql.Eq,
		LHS: append(prefix, spansql.ID("shipper_id")),
		RHS: spansql.StringLiteral(k.ShipperId),
	})
	if k.ValidSiteId {
		b = spansql.LogicalOp{
			Op:  spansql.And,
			LHS: b,
			RHS: spansql.ComparisonOp{
				Op:  spansql.Eq,
				LHS: append(prefix, spansql.ID("site_id")),
				RHS: spansql.StringLiteral(k.SiteId),
			},
		}
	}
	return spansql.Paren{Expr: b}
}

type SitesKeyRange struct {
	Start SitesKeyPrefix
	End   SitesKeyPrefix
	Kind  spanner.KeyRangeKind
}

func (k SitesKeyRange) SpannerKeySet() spanner.KeySet {
	return spanner.KeyRange{
		Start: k.Start.SpannerKey(),
		End:   k.End.SpannerKey(),
		Kind:  k.Kind,
	}
}

type SitesRow struct {
	ShipperId   string              `spanner:"shipper_id"`
	SiteId      string              `spanner:"site_id"`
	CreateTime  time.Time           `spanner:"create_time"`
	UpdateTime  time.Time           `spanner:"update_time"`
	DeleteTime  spanner.NullTime    `spanner:"delete_time"`
	DisplayName spanner.NullString  `spanner:"display_name"`
	Latitude    spanner.NullFloat64 `spanner:"latitude"`
	Longitude   spanner.NullFloat64 `spanner:"longitude"`
}

func (*SitesRow) ColumnNames() []string {
	return []string{
		"shipper_id",
		"site_id",
		"create_time",
		"update_time",
		"delete_time",
		"display_name",
		"latitude",
		"longitude",
	}
}

func (*SitesRow) ColumnIDs() []spansql.ID {
	return []spansql.ID{
		"shipper_id",
		"site_id",
		"create_time",
		"update_time",
		"delete_time",
		"display_name",
		"latitude",
		"longitude",
	}
}

func (*SitesRow) ColumnExprs() []spansql.Expr {
	return []spansql.Expr{
		spansql.ID("shipper_id"),
		spansql.ID("site_id"),
		spansql.ID("create_time"),
		spansql.ID("update_time"),
		spansql.ID("delete_time"),
		spansql.ID("display_name"),
		spansql.ID("latitude"),
		spansql.ID("longitude"),
	}
}

func (r *SitesRow) Validate() error {
	if len(r.ShipperId) > 63 {
		return fmt.Errorf("column shipper_id length > 63")
	}
	if len(r.SiteId) > 63 {
		return fmt.Errorf("column site_id length > 63")
	}
	if !r.DisplayName.IsNull() && len(r.DisplayName.StringVal) > 63 {
		return fmt.Errorf("column display_name length > 63")
	}
	return nil
}

func (r *SitesRow) UnmarshalSpannerRow(row *spanner.Row) error {
	for i := 0; i < row.Size(); i++ {
		switch row.ColumnName(i) {
		case "shipper_id":
			if err := row.Column(i, &r.ShipperId); err != nil {
				return fmt.Errorf("unmarshal sites row: shipper_id column: %w", err)
			}
		case "site_id":
			if err := row.Column(i, &r.SiteId); err != nil {
				return fmt.Errorf("unmarshal sites row: site_id column: %w", err)
			}
		case "create_time":
			if err := row.Column(i, &r.CreateTime); err != nil {
				return fmt.Errorf("unmarshal sites row: create_time column: %w", err)
			}
		case "update_time":
			if err := row.Column(i, &r.UpdateTime); err != nil {
				return fmt.Errorf("unmarshal sites row: update_time column: %w", err)
			}
		case "delete_time":
			if err := row.Column(i, &r.DeleteTime); err != nil {
				return fmt.Errorf("unmarshal sites row: delete_time column: %w", err)
			}
		case "display_name":
			if err := row.Column(i, &r.DisplayName); err != nil {
				return fmt.Errorf("unmarshal sites row: display_name column: %w", err)
			}
		case "latitude":
			if err := row.Column(i, &r.Latitude); err != nil {
				return fmt.Errorf("unmarshal sites row: latitude column: %w", err)
			}
		case "longitude":
			if err := row.Column(i, &r.Longitude); err != nil {
				return fmt.Errorf("unmarshal sites row: longitude column: %w", err)
			}
		default:
			return fmt.Errorf("unmarshal sites row: unhandled column: %s", row.ColumnName(i))
		}
	}
	return nil
}

func (r *SitesRow) Insert() *spanner.Mutation {
	return spanner.Insert(r.Mutation())
}

func (r *SitesRow) InsertOrUpdate() *spanner.Mutation {
	return spanner.InsertOrUpdate(r.Mutation())
}

func (r *SitesRow) Update() *spanner.Mutation {
	return spanner.Update(r.Mutation())
}

func (r *SitesRow) InsertColumns(columns []string) *spanner.Mutation {
	return spanner.Insert(r.MutationForColumns(columns))
}

func (r *SitesRow) InsertOrUpdateColumns(columns []string) *spanner.Mutation {
	return spanner.InsertOrUpdate(r.MutationForColumns(columns))
}

func (r *SitesRow) UpdateColumns(columns []string) *spanner.Mutation {
	return spanner.Update(r.MutationForColumns(columns))
}

func (r *SitesRow) Mutation() (string, []string, []interface{}) {
	return "sites", r.ColumnNames(), []interface{}{
		r.ShipperId,
		r.SiteId,
		r.CreateTime,
		r.UpdateTime,
		r.DeleteTime,
		r.DisplayName,
		r.Latitude,
		r.Longitude,
	}
}

func (r *SitesRow) MutationForColumns(columns []string) (string, []string, []interface{}) {
	if len(columns) == 0 {
		columns = r.ColumnNames()
	}
	values := make([]interface{}, 0, len(columns))
	for _, column := range columns {
		switch column {
		case "shipper_id":
			values = append(values, r.ShipperId)
		case "site_id":
			values = append(values, r.SiteId)
		case "create_time":
			values = append(values, r.CreateTime)
		case "update_time":
			values = append(values, r.UpdateTime)
		case "delete_time":
			values = append(values, r.DeleteTime)
		case "display_name":
			values = append(values, r.DisplayName)
		case "latitude":
			values = append(values, r.Latitude)
		case "longitude":
			values = append(values, r.Longitude)
		default:
			panic(fmt.Errorf("table sites does not have column %s", column))
		}
	}
	return "sites", columns, values
}

func (r *SitesRow) PrimaryKey() SitesKey {
	return SitesKey{
		ShipperId: r.ShipperId,
		SiteId:    r.SiteId,
	}
}

type ShipmentsReadTransaction struct {
	Tx SpannerReadTransaction
}

func Shipments(tx SpannerReadTransaction) ShipmentsReadTransaction {
	return ShipmentsReadTransaction{Tx: tx}
}

func (t ShipmentsReadTransaction) Read(
	ctx context.Context,
	keySet spanner.KeySet,
) *ShipmentsRowIterator {
	return &ShipmentsRowIterator{
		RowIterator: t.Tx.Read(
			ctx,
			"shipments",
			keySet,
			((*ShipmentsRow)(nil)).ColumnNames(),
		),
	}
}

func (t ShipmentsReadTransaction) Get(
	ctx context.Context,
	key ShipmentsKey,
) (*ShipmentsRow, error) {
	spannerRow, err := t.Tx.ReadRow(
		ctx,
		"shipments",
		key.SpannerKey(),
		((*ShipmentsRow)(nil)).ColumnNames(),
	)
	if err != nil {
		return nil, err
	}
	var row ShipmentsRow
	if err := row.UnmarshalSpannerRow(spannerRow); err != nil {
		return nil, err
	}
	return &row, nil
}

func (t ShipmentsReadTransaction) BatchGet(
	ctx context.Context,
	keys []ShipmentsKey,
) (map[ShipmentsKey]*ShipmentsRow, error) {
	spannerKeys := make([]spanner.KeySet, 0, len(keys))
	for _, key := range keys {
		spannerKeys = append(spannerKeys, key.SpannerKey())
	}
	foundRows := make(map[ShipmentsKey]*ShipmentsRow, len(keys))
	if err := t.Read(ctx, spanner.KeySets(spannerKeys...)).Do(func(row *ShipmentsRow) error {
		foundRows[row.PrimaryKey()] = row
		return nil
	}); err != nil {
		return nil, err
	}
	return foundRows, nil
}

func (t ShipmentsReadTransaction) List(
	ctx context.Context,
	query ListQuery,
) *ShipmentsRowIterator {
	stmt := spanner.Statement{
		SQL: spansql.Query{
			Select: spansql.Select{
				List: ((*ShipmentsRow)(nil)).ColumnExprs(),
				From: []spansql.SelectFrom{
					spansql.SelectFromTable{Table: "shipments"},
				},
				Where: query.Where,
			},
			Order:  query.Order,
			Limit:  spansql.Param("limit"),
			Offset: spansql.Param("offset"),
		}.SQL(),
		Params: map[string]interface{}{
			"limit":  query.Limit,
			"offset": query.Offset,
		},
	}
	return &ShipmentsRowIterator{
		RowIterator: t.Tx.Query(ctx, stmt),
	}
}

type ShipmentsRowIterator struct {
	*spanner.RowIterator
}

func (i *ShipmentsRowIterator) Next() (*ShipmentsRow, error) {
	spannerRow, err := i.RowIterator.Next()
	if err != nil {
		return nil, err
	}
	var row ShipmentsRow
	if err := row.UnmarshalSpannerRow(spannerRow); err != nil {
		return nil, err
	}
	return &row, nil
}

func (i *ShipmentsRowIterator) Do(f func(row *ShipmentsRow) error) error {
	return i.RowIterator.Do(func(spannerRow *spanner.Row) error {
		var row ShipmentsRow
		if err := row.UnmarshalSpannerRow(spannerRow); err != nil {
			return err
		}
		return f(&row)
	})
}

type ShipmentsKey struct {
	ShipperId  string
	ShipmentId string
}

func (k ShipmentsKey) SpannerKey() spanner.Key {
	return spanner.Key{
		k.ShipperId,
		k.ShipmentId,
	}
}

func (k ShipmentsKey) SpannerKeySet() spanner.KeySet {
	return k.SpannerKey()
}

func (k ShipmentsKey) Delete() *spanner.Mutation {
	return spanner.Delete("shipments", k.SpannerKey())
}

func (k ShipmentsKey) BoolExpr() spansql.BoolExpr {
	b := spansql.BoolExpr(spansql.ComparisonOp{
		Op:  spansql.Eq,
		LHS: spansql.ID("shipper_id"),
		RHS: spansql.StringLiteral(k.ShipperId),
	})
	b = spansql.LogicalOp{
		Op:  spansql.And,
		LHS: b,
		RHS: spansql.ComparisonOp{
			Op:  spansql.Eq,
			LHS: spansql.ID("shipment_id"),
			RHS: spansql.StringLiteral(k.ShipmentId),
		},
	}
	return spansql.Paren{Expr: b}
}

func (k ShipmentsKey) QualifiedBoolExpr(prefix spansql.PathExp) spansql.BoolExpr {
	b := spansql.BoolExpr(spansql.ComparisonOp{
		Op:  spansql.Eq,
		LHS: append(prefix, spansql.ID("shipper_id")),
		RHS: spansql.StringLiteral(k.ShipperId),
	})
	b = spansql.LogicalOp{
		Op:  spansql.And,
		LHS: b,
		RHS: spansql.ComparisonOp{
			Op:  spansql.Eq,
			LHS: append(prefix, spansql.ID("shipment_id")),
			RHS: spansql.StringLiteral(k.ShipmentId),
		},
	}
	return spansql.Paren{Expr: b}
}

type ShipmentsKeyPrefix struct {
	ShipperId       string
	ShipmentId      string
	ValidShipmentId bool
}

func (k ShipmentsKeyPrefix) SpannerKey() spanner.Key {
	n := 1
	if k.ValidShipmentId {
		n++
	}
	result := make(spanner.Key, 0, n)
	result = append(result, k.ShipperId)
	if k.ValidShipmentId {
		result = append(result, k.ShipmentId)
	}
	return result
}

func (k ShipmentsKeyPrefix) SpannerKeySet() spanner.KeySet {
	return k.SpannerKey()
}

func (k ShipmentsKeyPrefix) Delete() *spanner.Mutation {
	return spanner.Delete("shipments", k.SpannerKey())
}

func (k ShipmentsKeyPrefix) BoolExpr() spansql.BoolExpr {
	b := spansql.BoolExpr(spansql.ComparisonOp{
		Op:  spansql.Eq,
		LHS: spansql.ID("shipper_id"),
		RHS: spansql.StringLiteral(k.ShipperId),
	})
	if k.ValidShipmentId {
		b = spansql.LogicalOp{
			Op:  spansql.And,
			LHS: b,
			RHS: spansql.ComparisonOp{
				Op:  spansql.Eq,
				LHS: spansql.ID("shipment_id"),
				RHS: spansql.StringLiteral(k.ShipmentId),
			},
		}
	}
	return spansql.Paren{Expr: b}
}

func (k ShipmentsKeyPrefix) QualifiedBoolExpr(prefix spansql.PathExp) spansql.BoolExpr {
	b := spansql.BoolExpr(spansql.ComparisonOp{
		Op:  spansql.Eq,
		LHS: append(prefix, spansql.ID("shipper_id")),
		RHS: spansql.StringLiteral(k.ShipperId),
	})
	if k.ValidShipmentId {
		b = spansql.LogicalOp{
			Op:  spansql.And,
			LHS: b,
			RHS: spansql.ComparisonOp{
				Op:  spansql.Eq,
				LHS: append(prefix, spansql.ID("shipment_id")),
				RHS: spansql.StringLiteral(k.ShipmentId),
			},
		}
	}
	return spansql.Paren{Expr: b}
}

type ShipmentsKeyRange struct {
	Start ShipmentsKeyPrefix
	End   ShipmentsKeyPrefix
	Kind  spanner.KeyRangeKind
}

func (k ShipmentsKeyRange) SpannerKeySet() spanner.KeySet {
	return spanner.KeyRange{
		Start: k.Start.SpannerKey(),
		End:   k.End.SpannerKey(),
		Kind:  k.Kind,
	}
}

type ShipmentsRow struct {
	ShipperId            string             `spanner:"shipper_id"`
	ShipmentId           string             `spanner:"shipment_id"`
	CreateTime           time.Time          `spanner:"create_time"`
	UpdateTime           time.Time          `spanner:"update_time"`
	DeleteTime           spanner.NullTime   `spanner:"delete_time"`
	OriginSiteId         spanner.NullString `spanner:"origin_site_id"`
	DestinationSiteId    spanner.NullString `spanner:"destination_site_id"`
	PickupEarliestTime   spanner.NullTime   `spanner:"pickup_earliest_time"`
	PickupLatestTime     spanner.NullTime   `spanner:"pickup_latest_time"`
	DeliveryEarliestTime spanner.NullTime   `spanner:"delivery_earliest_time"`
	DeliveryLatestTime   spanner.NullTime   `spanner:"delivery_latest_time"`
}

func (*ShipmentsRow) ColumnNames() []string {
	return []string{
		"shipper_id",
		"shipment_id",
		"create_time",
		"update_time",
		"delete_time",
		"origin_site_id",
		"destination_site_id",
		"pickup_earliest_time",
		"pickup_latest_time",
		"delivery_earliest_time",
		"delivery_latest_time",
	}
}

func (*ShipmentsRow) ColumnIDs() []spansql.ID {
	return []spansql.ID{
		"shipper_id",
		"shipment_id",
		"create_time",
		"update_time",
		"delete_time",
		"origin_site_id",
		"destination_site_id",
		"pickup_earliest_time",
		"pickup_latest_time",
		"delivery_earliest_time",
		"delivery_latest_time",
	}
}

func (*ShipmentsRow) ColumnExprs() []spansql.Expr {
	return []spansql.Expr{
		spansql.ID("shipper_id"),
		spansql.ID("shipment_id"),
		spansql.ID("create_time"),
		spansql.ID("update_time"),
		spansql.ID("delete_time"),
		spansql.ID("origin_site_id"),
		spansql.ID("destination_site_id"),
		spansql.ID("pickup_earliest_time"),
		spansql.ID("pickup_latest_time"),
		spansql.ID("delivery_earliest_time"),
		spansql.ID("delivery_latest_time"),
	}
}

func (r *ShipmentsRow) Validate() error {
	if len(r.ShipperId) > 63 {
		return fmt.Errorf("column shipper_id length > 63")
	}
	if len(r.ShipmentId) > 63 {
		return fmt.Errorf("column shipment_id length > 63")
	}
	if !r.OriginSiteId.IsNull() && len(r.OriginSiteId.StringVal) > 63 {
		return fmt.Errorf("column origin_site_id length > 63")
	}
	if !r.DestinationSiteId.IsNull() && len(r.DestinationSiteId.StringVal) > 63 {
		return fmt.Errorf("column destination_site_id length > 63")
	}
	return nil
}

func (r *ShipmentsRow) UnmarshalSpannerRow(row *spanner.Row) error {
	for i := 0; i < row.Size(); i++ {
		switch row.ColumnName(i) {
		case "shipper_id":
			if err := row.Column(i, &r.ShipperId); err != nil {
				return fmt.Errorf("unmarshal shipments row: shipper_id column: %w", err)
			}
		case "shipment_id":
			if err := row.Column(i, &r.ShipmentId); err != nil {
				return fmt.Errorf("unmarshal shipments row: shipment_id column: %w", err)
			}
		case "create_time":
			if err := row.Column(i, &r.CreateTime); err != nil {
				return fmt.Errorf("unmarshal shipments row: create_time column: %w", err)
			}
		case "update_time":
			if err := row.Column(i, &r.UpdateTime); err != nil {
				return fmt.Errorf("unmarshal shipments row: update_time column: %w", err)
			}
		case "delete_time":
			if err := row.Column(i, &r.DeleteTime); err != nil {
				return fmt.Errorf("unmarshal shipments row: delete_time column: %w", err)
			}
		case "origin_site_id":
			if err := row.Column(i, &r.OriginSiteId); err != nil {
				return fmt.Errorf("unmarshal shipments row: origin_site_id column: %w", err)
			}
		case "destination_site_id":
			if err := row.Column(i, &r.DestinationSiteId); err != nil {
				return fmt.Errorf("unmarshal shipments row: destination_site_id column: %w", err)
			}
		case "pickup_earliest_time":
			if err := row.Column(i, &r.PickupEarliestTime); err != nil {
				return fmt.Errorf("unmarshal shipments row: pickup_earliest_time column: %w", err)
			}
		case "pickup_latest_time":
			if err := row.Column(i, &r.PickupLatestTime); err != nil {
				return fmt.Errorf("unmarshal shipments row: pickup_latest_time column: %w", err)
			}
		case "delivery_earliest_time":
			if err := row.Column(i, &r.DeliveryEarliestTime); err != nil {
				return fmt.Errorf("unmarshal shipments row: delivery_earliest_time column: %w", err)
			}
		case "delivery_latest_time":
			if err := row.Column(i, &r.DeliveryLatestTime); err != nil {
				return fmt.Errorf("unmarshal shipments row: delivery_latest_time column: %w", err)
			}
		default:
			return fmt.Errorf("unmarshal shipments row: unhandled column: %s", row.ColumnName(i))
		}
	}
	return nil
}

func (r *ShipmentsRow) Insert() *spanner.Mutation {
	return spanner.Insert(r.Mutation())
}

func (r *ShipmentsRow) InsertOrUpdate() *spanner.Mutation {
	return spanner.InsertOrUpdate(r.Mutation())
}

func (r *ShipmentsRow) Update() *spanner.Mutation {
	return spanner.Update(r.Mutation())
}

func (r *ShipmentsRow) InsertColumns(columns []string) *spanner.Mutation {
	return spanner.Insert(r.MutationForColumns(columns))
}

func (r *ShipmentsRow) InsertOrUpdateColumns(columns []string) *spanner.Mutation {
	return spanner.InsertOrUpdate(r.MutationForColumns(columns))
}

func (r *ShipmentsRow) UpdateColumns(columns []string) *spanner.Mutation {
	return spanner.Update(r.MutationForColumns(columns))
}

func (r *ShipmentsRow) Mutation() (string, []string, []interface{}) {
	return "shipments", r.ColumnNames(), []interface{}{
		r.ShipperId,
		r.ShipmentId,
		r.CreateTime,
		r.UpdateTime,
		r.DeleteTime,
		r.OriginSiteId,
		r.DestinationSiteId,
		r.PickupEarliestTime,
		r.PickupLatestTime,
		r.DeliveryEarliestTime,
		r.DeliveryLatestTime,
	}
}

func (r *ShipmentsRow) MutationForColumns(columns []string) (string, []string, []interface{}) {
	if len(columns) == 0 {
		columns = r.ColumnNames()
	}
	values := make([]interface{}, 0, len(columns))
	for _, column := range columns {
		switch column {
		case "shipper_id":
			values = append(values, r.ShipperId)
		case "shipment_id":
			values = append(values, r.ShipmentId)
		case "create_time":
			values = append(values, r.CreateTime)
		case "update_time":
			values = append(values, r.UpdateTime)
		case "delete_time":
			values = append(values, r.DeleteTime)
		case "origin_site_id":
			values = append(values, r.OriginSiteId)
		case "destination_site_id":
			values = append(values, r.DestinationSiteId)
		case "pickup_earliest_time":
			values = append(values, r.PickupEarliestTime)
		case "pickup_latest_time":
			values = append(values, r.PickupLatestTime)
		case "delivery_earliest_time":
			values = append(values, r.DeliveryEarliestTime)
		case "delivery_latest_time":
			values = append(values, r.DeliveryLatestTime)
		default:
			panic(fmt.Errorf("table shipments does not have column %s", column))
		}
	}
	return "shipments", columns, values
}

func (r *ShipmentsRow) PrimaryKey() ShipmentsKey {
	return ShipmentsKey{
		ShipperId:  r.ShipperId,
		ShipmentId: r.ShipmentId,
	}
}

type ShipmentsAndLineItemsReadTransaction struct {
	Tx SpannerReadTransaction
}

func ShipmentsAndLineItems(tx SpannerReadTransaction) ShipmentsAndLineItemsReadTransaction {
	return ShipmentsAndLineItemsReadTransaction{Tx: tx}
}

func (t ShipmentsAndLineItemsReadTransaction) List(
	ctx context.Context,
	query ListQuery,
) *ShipmentsAndLineItemsRowIterator {
	var q strings.Builder
	_, _ = q.WriteString("SELECT ")
	_, _ = q.WriteString("shipper_id, ")
	_, _ = q.WriteString("shipment_id, ")
	_, _ = q.WriteString("create_time, ")
	_, _ = q.WriteString("update_time, ")
	_, _ = q.WriteString("delete_time, ")
	_, _ = q.WriteString("origin_site_id, ")
	_, _ = q.WriteString("destination_site_id, ")
	_, _ = q.WriteString("pickup_earliest_time, ")
	_, _ = q.WriteString("pickup_latest_time, ")
	_, _ = q.WriteString("delivery_earliest_time, ")
	_, _ = q.WriteString("delivery_latest_time, ")
	_, _ = q.WriteString("ARRAY( ")
	_, _ = q.WriteString("SELECT AS STRUCT ")
	_, _ = q.WriteString("shipper_id, ")
	_, _ = q.WriteString("shipment_id, ")
	_, _ = q.WriteString("line_number, ")
	_, _ = q.WriteString("title, ")
	_, _ = q.WriteString("quantity, ")
	_, _ = q.WriteString("weight_kg, ")
	_, _ = q.WriteString("volume_m3, ")
	_, _ = q.WriteString("FROM line_items ")
	_, _ = q.WriteString("WHERE ")
	_, _ = q.WriteString("shipper_id = shipments.shipper_id ")
	_, _ = q.WriteString("AND ")
	_, _ = q.WriteString("shipment_id = shipments.shipment_id ")
	_, _ = q.WriteString(") AS line_items, ")
	_, _ = q.WriteString("FROM shipments ")
	if query.Where != nil {
		_, _ = q.WriteString("WHERE (")
		_, _ = q.WriteString(query.Where.SQL())
		_, _ = q.WriteString(") ")
	}
	if len(query.Order) > 0 {
		_, _ = q.WriteString("ORDER BY ")
		for i, order := range query.Order {
			_, _ = q.WriteString(order.SQL())
			if i < len(query.Order)-1 {
				_, _ = q.WriteString(", ")
			}
		}
	}
	_, _ = q.WriteString("LIMIT @limit ")
	_, _ = q.WriteString("OFFSET @offset ")
	stmt := spanner.Statement{
		SQL: q.String(),
		Params: map[string]interface{}{
			"limit":  query.Limit,
			"offset": query.Offset,
		},
	}
	return &ShipmentsAndLineItemsRowIterator{
		RowIterator: t.Tx.Query(ctx, stmt),
	}
}

func (t ShipmentsAndLineItemsReadTransaction) Get(
	ctx context.Context,
	key ShipmentsKey,
) (*ShipmentsAndLineItemsRow, error) {
	it := t.List(ctx, ListQuery{
		Where: key.BoolExpr(),
		Limit: 1,
	})
	defer it.Stop()
	row, err := it.Next()
	if err != nil {
		if err == iterator.Done {
			return nil, status.Errorf(codes.NotFound, "not found: %v", key)
		}
		return nil, err
	}
	return row, nil
}

func (t ShipmentsAndLineItemsReadTransaction) BatchGet(
	ctx context.Context,
	keys []ShipmentsKey,
) (map[ShipmentsKey]*ShipmentsAndLineItemsRow, error) {
	if len(keys) == 0 {
		return nil, nil
	}
	where := keys[0].BoolExpr()
	for _, key := range keys[1:] {
		where = spansql.LogicalOp{
			Op:  spansql.Or,
			LHS: where,
			RHS: key.BoolExpr(),
		}
	}
	foundRows := make(map[ShipmentsKey]*ShipmentsAndLineItemsRow, len(keys))
	if err := t.List(ctx, ListQuery{
		Where: spansql.Paren{Expr: where},
		Limit: int64(len(keys)),
	}).Do(func(row *ShipmentsAndLineItemsRow) error {
		foundRows[row.ShipmentsKey()] = row
		return nil
	}); err != nil {
		return nil, err
	}
	return foundRows, nil
}

type ShipmentsAndLineItemsRowIterator struct {
	*spanner.RowIterator
}

func (i *ShipmentsAndLineItemsRowIterator) Next() (*ShipmentsAndLineItemsRow, error) {
	spannerRow, err := i.RowIterator.Next()
	if err != nil {
		return nil, err
	}
	var row ShipmentsAndLineItemsRow
	if err := row.UnmarshalSpannerRow(spannerRow); err != nil {
		return nil, err
	}
	return &row, nil
}

func (i *ShipmentsAndLineItemsRowIterator) Do(f func(row *ShipmentsAndLineItemsRow) error) error {
	return i.RowIterator.Do(func(spannerRow *spanner.Row) error {
		var row ShipmentsAndLineItemsRow
		if err := row.UnmarshalSpannerRow(spannerRow); err != nil {
			return err
		}
		return f(&row)
	})
}

type ShipmentsAndLineItemsRow struct {
	ShipperId            string             `spanner:"shipper_id"`
	ShipmentId           string             `spanner:"shipment_id"`
	CreateTime           time.Time          `spanner:"create_time"`
	UpdateTime           time.Time          `spanner:"update_time"`
	DeleteTime           spanner.NullTime   `spanner:"delete_time"`
	OriginSiteId         spanner.NullString `spanner:"origin_site_id"`
	DestinationSiteId    spanner.NullString `spanner:"destination_site_id"`
	PickupEarliestTime   spanner.NullTime   `spanner:"pickup_earliest_time"`
	PickupLatestTime     spanner.NullTime   `spanner:"pickup_latest_time"`
	DeliveryEarliestTime spanner.NullTime   `spanner:"delivery_earliest_time"`
	DeliveryLatestTime   spanner.NullTime   `spanner:"delivery_latest_time"`
	LineItems            []*LineItemsRow    `spanner:"line_items"`
}

func (r *ShipmentsAndLineItemsRow) ShipmentsKey() ShipmentsKey {
	return ShipmentsKey{
		ShipperId:  r.ShipperId,
		ShipmentId: r.ShipmentId,
	}
}

func (r ShipmentsAndLineItemsRow) LineItemsKeyPrefix() LineItemsKeyPrefix {
	return LineItemsKeyPrefix{
		ShipperId:       r.ShipperId,
		ShipmentId:      r.ShipmentId,
		ValidShipmentId: true,
	}
}

func (r *ShipmentsAndLineItemsRow) UnmarshalSpannerRow(row *spanner.Row) error {
	for i := 0; i < row.Size(); i++ {
		switch row.ColumnName(i) {
		case "shipper_id":
			if err := row.Column(i, &r.ShipperId); err != nil {
				return fmt.Errorf("unmarshal shipments row: shipper_id column: %w", err)
			}
		case "shipment_id":
			if err := row.Column(i, &r.ShipmentId); err != nil {
				return fmt.Errorf("unmarshal shipments row: shipment_id column: %w", err)
			}
		case "create_time":
			if err := row.Column(i, &r.CreateTime); err != nil {
				return fmt.Errorf("unmarshal shipments row: create_time column: %w", err)
			}
		case "update_time":
			if err := row.Column(i, &r.UpdateTime); err != nil {
				return fmt.Errorf("unmarshal shipments row: update_time column: %w", err)
			}
		case "delete_time":
			if err := row.Column(i, &r.DeleteTime); err != nil {
				return fmt.Errorf("unmarshal shipments row: delete_time column: %w", err)
			}
		case "origin_site_id":
			if err := row.Column(i, &r.OriginSiteId); err != nil {
				return fmt.Errorf("unmarshal shipments row: origin_site_id column: %w", err)
			}
		case "destination_site_id":
			if err := row.Column(i, &r.DestinationSiteId); err != nil {
				return fmt.Errorf("unmarshal shipments row: destination_site_id column: %w", err)
			}
		case "pickup_earliest_time":
			if err := row.Column(i, &r.PickupEarliestTime); err != nil {
				return fmt.Errorf("unmarshal shipments row: pickup_earliest_time column: %w", err)
			}
		case "pickup_latest_time":
			if err := row.Column(i, &r.PickupLatestTime); err != nil {
				return fmt.Errorf("unmarshal shipments row: pickup_latest_time column: %w", err)
			}
		case "delivery_earliest_time":
			if err := row.Column(i, &r.DeliveryEarliestTime); err != nil {
				return fmt.Errorf("unmarshal shipments row: delivery_earliest_time column: %w", err)
			}
		case "delivery_latest_time":
			if err := row.Column(i, &r.DeliveryLatestTime); err != nil {
				return fmt.Errorf("unmarshal shipments row: delivery_latest_time column: %w", err)
			}
		case "line_items":
			if err := row.Column(i, &r.LineItems); err != nil {
				return fmt.Errorf("unmarshal shipments interleaved row: line_items column: %w", err)
			}
		default:
			return fmt.Errorf("unmarshal shipments row: unhandled column: %s", row.ColumnName(i))
		}
	}
	return nil
}

func (r ShipmentsAndLineItemsRow) ShipmentsRow() *ShipmentsRow {
	return &ShipmentsRow{
		ShipperId:            r.ShipperId,
		ShipmentId:           r.ShipmentId,
		CreateTime:           r.CreateTime,
		UpdateTime:           r.UpdateTime,
		DeleteTime:           r.DeleteTime,
		OriginSiteId:         r.OriginSiteId,
		DestinationSiteId:    r.DestinationSiteId,
		PickupEarliestTime:   r.PickupEarliestTime,
		PickupLatestTime:     r.PickupLatestTime,
		DeliveryEarliestTime: r.DeliveryEarliestTime,
		DeliveryLatestTime:   r.DeliveryLatestTime,
	}
}

func (r ShipmentsAndLineItemsRow) Insert() []*spanner.Mutation {
	n := 1
	n += len(r.LineItems)
	mutations := make([]*spanner.Mutation, 0, n)
	mutations = append(mutations, r.ShipmentsRow().Insert())
	for _, interleavedRow := range r.LineItems {
		mutations = append(mutations, interleavedRow.Insert())
	}
	return mutations
}

func (r ShipmentsAndLineItemsRow) Update() []*spanner.Mutation {
	n := 2 // one delete mutation per interleaved table
	n += len(r.LineItems)
	mutations := make([]*spanner.Mutation, 0, n)
	mutations = append(mutations, r.ShipmentsRow().Update())
	mutations = append(mutations, r.LineItemsKeyPrefix().Delete())
	for _, interleavedRow := range r.LineItems {
		mutations = append(mutations, interleavedRow.Insert())
	}
	return mutations
}

type LineItemsReadTransaction struct {
	Tx SpannerReadTransaction
}

func LineItems(tx SpannerReadTransaction) LineItemsReadTransaction {
	return LineItemsReadTransaction{Tx: tx}
}

func (t LineItemsReadTransaction) Read(
	ctx context.Context,
	keySet spanner.KeySet,
) *LineItemsRowIterator {
	return &LineItemsRowIterator{
		RowIterator: t.Tx.Read(
			ctx,
			"line_items",
			keySet,
			((*LineItemsRow)(nil)).ColumnNames(),
		),
	}
}

func (t LineItemsReadTransaction) Get(
	ctx context.Context,
	key LineItemsKey,
) (*LineItemsRow, error) {
	spannerRow, err := t.Tx.ReadRow(
		ctx,
		"line_items",
		key.SpannerKey(),
		((*LineItemsRow)(nil)).ColumnNames(),
	)
	if err != nil {
		return nil, err
	}
	var row LineItemsRow
	if err := row.UnmarshalSpannerRow(spannerRow); err != nil {
		return nil, err
	}
	return &row, nil
}

func (t LineItemsReadTransaction) BatchGet(
	ctx context.Context,
	keys []LineItemsKey,
) (map[LineItemsKey]*LineItemsRow, error) {
	spannerKeys := make([]spanner.KeySet, 0, len(keys))
	for _, key := range keys {
		spannerKeys = append(spannerKeys, key.SpannerKey())
	}
	foundRows := make(map[LineItemsKey]*LineItemsRow, len(keys))
	if err := t.Read(ctx, spanner.KeySets(spannerKeys...)).Do(func(row *LineItemsRow) error {
		foundRows[row.PrimaryKey()] = row
		return nil
	}); err != nil {
		return nil, err
	}
	return foundRows, nil
}

func (t LineItemsReadTransaction) List(
	ctx context.Context,
	query ListQuery,
) *LineItemsRowIterator {
	stmt := spanner.Statement{
		SQL: spansql.Query{
			Select: spansql.Select{
				List: ((*LineItemsRow)(nil)).ColumnExprs(),
				From: []spansql.SelectFrom{
					spansql.SelectFromTable{Table: "line_items"},
				},
				Where: query.Where,
			},
			Order:  query.Order,
			Limit:  spansql.Param("limit"),
			Offset: spansql.Param("offset"),
		}.SQL(),
		Params: map[string]interface{}{
			"limit":  query.Limit,
			"offset": query.Offset,
		},
	}
	return &LineItemsRowIterator{
		RowIterator: t.Tx.Query(ctx, stmt),
	}
}

type LineItemsRowIterator struct {
	*spanner.RowIterator
}

func (i *LineItemsRowIterator) Next() (*LineItemsRow, error) {
	spannerRow, err := i.RowIterator.Next()
	if err != nil {
		return nil, err
	}
	var row LineItemsRow
	if err := row.UnmarshalSpannerRow(spannerRow); err != nil {
		return nil, err
	}
	return &row, nil
}

func (i *LineItemsRowIterator) Do(f func(row *LineItemsRow) error) error {
	return i.RowIterator.Do(func(spannerRow *spanner.Row) error {
		var row LineItemsRow
		if err := row.UnmarshalSpannerRow(spannerRow); err != nil {
			return err
		}
		return f(&row)
	})
}

type LineItemsKey struct {
	ShipperId  string
	ShipmentId string
	LineNumber int64
}

func (k LineItemsKey) SpannerKey() spanner.Key {
	return spanner.Key{
		k.ShipperId,
		k.ShipmentId,
		k.LineNumber,
	}
}

func (k LineItemsKey) SpannerKeySet() spanner.KeySet {
	return k.SpannerKey()
}

func (k LineItemsKey) Delete() *spanner.Mutation {
	return spanner.Delete("line_items", k.SpannerKey())
}

func (k LineItemsKey) BoolExpr() spansql.BoolExpr {
	b := spansql.BoolExpr(spansql.ComparisonOp{
		Op:  spansql.Eq,
		LHS: spansql.ID("shipper_id"),
		RHS: spansql.StringLiteral(k.ShipperId),
	})
	b = spansql.LogicalOp{
		Op:  spansql.And,
		LHS: b,
		RHS: spansql.ComparisonOp{
			Op:  spansql.Eq,
			LHS: spansql.ID("shipment_id"),
			RHS: spansql.StringLiteral(k.ShipmentId),
		},
	}
	b = spansql.LogicalOp{
		Op:  spansql.And,
		LHS: b,
		RHS: spansql.ComparisonOp{
			Op:  spansql.Eq,
			LHS: spansql.ID("line_number"),
			RHS: spansql.IntegerLiteral(k.LineNumber),
		},
	}
	return spansql.Paren{Expr: b}
}

func (k LineItemsKey) QualifiedBoolExpr(prefix spansql.PathExp) spansql.BoolExpr {
	b := spansql.BoolExpr(spansql.ComparisonOp{
		Op:  spansql.Eq,
		LHS: append(prefix, spansql.ID("shipper_id")),
		RHS: spansql.StringLiteral(k.ShipperId),
	})
	b = spansql.LogicalOp{
		Op:  spansql.And,
		LHS: b,
		RHS: spansql.ComparisonOp{
			Op:  spansql.Eq,
			LHS: append(prefix, spansql.ID("shipment_id")),
			RHS: spansql.StringLiteral(k.ShipmentId),
		},
	}
	b = spansql.LogicalOp{
		Op:  spansql.And,
		LHS: b,
		RHS: spansql.ComparisonOp{
			Op:  spansql.Eq,
			LHS: append(prefix, spansql.ID("line_number")),
			RHS: spansql.IntegerLiteral(k.LineNumber),
		},
	}
	return spansql.Paren{Expr: b}
}

type LineItemsKeyPrefix struct {
	ShipperId       string
	ShipmentId      string
	ValidShipmentId bool
	LineNumber      int64
	ValidLineNumber bool
}

func (k LineItemsKeyPrefix) SpannerKey() spanner.Key {
	n := 1
	if k.ValidShipmentId {
		n++
		if k.ValidLineNumber {
			n++
		}
	}
	result := make(spanner.Key, 0, n)
	result = append(result, k.ShipperId)
	if k.ValidShipmentId {
		result = append(result, k.ShipmentId)
		if k.ValidLineNumber {
			result = append(result, k.LineNumber)
		}
	}
	return result
}

func (k LineItemsKeyPrefix) SpannerKeySet() spanner.KeySet {
	return k.SpannerKey()
}

func (k LineItemsKeyPrefix) Delete() *spanner.Mutation {
	return spanner.Delete("line_items", k.SpannerKey())
}

func (k LineItemsKeyPrefix) BoolExpr() spansql.BoolExpr {
	b := spansql.BoolExpr(spansql.ComparisonOp{
		Op:  spansql.Eq,
		LHS: spansql.ID("shipper_id"),
		RHS: spansql.StringLiteral(k.ShipperId),
	})
	if k.ValidShipmentId {
		b = spansql.LogicalOp{
			Op:  spansql.And,
			LHS: b,
			RHS: spansql.ComparisonOp{
				Op:  spansql.Eq,
				LHS: spansql.ID("shipment_id"),
				RHS: spansql.StringLiteral(k.ShipmentId),
			},
		}
		if k.ValidLineNumber {
			b = spansql.LogicalOp{
				Op:  spansql.And,
				LHS: b,
				RHS: spansql.ComparisonOp{
					Op:  spansql.Eq,
					LHS: spansql.ID("line_number"),
					RHS: spansql.IntegerLiteral(k.LineNumber),
				},
			}
		}
	}
	return spansql.Paren{Expr: b}
}

func (k LineItemsKeyPrefix) QualifiedBoolExpr(prefix spansql.PathExp) spansql.BoolExpr {
	b := spansql.BoolExpr(spansql.ComparisonOp{
		Op:  spansql.Eq,
		LHS: append(prefix, spansql.ID("shipper_id")),
		RHS: spansql.StringLiteral(k.ShipperId),
	})
	if k.ValidShipmentId {
		b = spansql.LogicalOp{
			Op:  spansql.And,
			LHS: b,
			RHS: spansql.ComparisonOp{
				Op:  spansql.Eq,
				LHS: append(prefix, spansql.ID("shipment_id")),
				RHS: spansql.StringLiteral(k.ShipmentId),
			},
		}
		if k.ValidLineNumber {
			b = spansql.LogicalOp{
				Op:  spansql.And,
				LHS: b,
				RHS: spansql.ComparisonOp{
					Op:  spansql.Eq,
					LHS: append(prefix, spansql.ID("line_number")),
					RHS: spansql.IntegerLiteral(k.LineNumber),
				},
			}
		}
	}
	return spansql.Paren{Expr: b}
}

type LineItemsKeyRange struct {
	Start LineItemsKeyPrefix
	End   LineItemsKeyPrefix
	Kind  spanner.KeyRangeKind
}

func (k LineItemsKeyRange) SpannerKeySet() spanner.KeySet {
	return spanner.KeyRange{
		Start: k.Start.SpannerKey(),
		End:   k.End.SpannerKey(),
		Kind:  k.Kind,
	}
}

type LineItemsRow struct {
	ShipperId  string              `spanner:"shipper_id"`
	ShipmentId string              `spanner:"shipment_id"`
	LineNumber int64               `spanner:"line_number"`
	Title      spanner.NullString  `spanner:"title"`
	Quantity   spanner.NullFloat64 `spanner:"quantity"`
	WeightKg   spanner.NullFloat64 `spanner:"weight_kg"`
	VolumeM3   spanner.NullFloat64 `spanner:"volume_m3"`
}

func (*LineItemsRow) ColumnNames() []string {
	return []string{
		"shipper_id",
		"shipment_id",
		"line_number",
		"title",
		"quantity",
		"weight_kg",
		"volume_m3",
	}
}

func (*LineItemsRow) ColumnIDs() []spansql.ID {
	return []spansql.ID{
		"shipper_id",
		"shipment_id",
		"line_number",
		"title",
		"quantity",
		"weight_kg",
		"volume_m3",
	}
}

func (*LineItemsRow) ColumnExprs() []spansql.Expr {
	return []spansql.Expr{
		spansql.ID("shipper_id"),
		spansql.ID("shipment_id"),
		spansql.ID("line_number"),
		spansql.ID("title"),
		spansql.ID("quantity"),
		spansql.ID("weight_kg"),
		spansql.ID("volume_m3"),
	}
}

func (r *LineItemsRow) Validate() error {
	if len(r.ShipperId) > 63 {
		return fmt.Errorf("column shipper_id length > 63")
	}
	if len(r.ShipmentId) > 63 {
		return fmt.Errorf("column shipment_id length > 63")
	}
	if !r.Title.IsNull() && len(r.Title.StringVal) > 63 {
		return fmt.Errorf("column title length > 63")
	}
	return nil
}

func (r *LineItemsRow) UnmarshalSpannerRow(row *spanner.Row) error {
	for i := 0; i < row.Size(); i++ {
		switch row.ColumnName(i) {
		case "shipper_id":
			if err := row.Column(i, &r.ShipperId); err != nil {
				return fmt.Errorf("unmarshal line_items row: shipper_id column: %w", err)
			}
		case "shipment_id":
			if err := row.Column(i, &r.ShipmentId); err != nil {
				return fmt.Errorf("unmarshal line_items row: shipment_id column: %w", err)
			}
		case "line_number":
			if err := row.Column(i, &r.LineNumber); err != nil {
				return fmt.Errorf("unmarshal line_items row: line_number column: %w", err)
			}
		case "title":
			if err := row.Column(i, &r.Title); err != nil {
				return fmt.Errorf("unmarshal line_items row: title column: %w", err)
			}
		case "quantity":
			if err := row.Column(i, &r.Quantity); err != nil {
				return fmt.Errorf("unmarshal line_items row: quantity column: %w", err)
			}
		case "weight_kg":
			if err := row.Column(i, &r.WeightKg); err != nil {
				return fmt.Errorf("unmarshal line_items row: weight_kg column: %w", err)
			}
		case "volume_m3":
			if err := row.Column(i, &r.VolumeM3); err != nil {
				return fmt.Errorf("unmarshal line_items row: volume_m3 column: %w", err)
			}
		default:
			return fmt.Errorf("unmarshal line_items row: unhandled column: %s", row.ColumnName(i))
		}
	}
	return nil
}

func (r *LineItemsRow) Insert() *spanner.Mutation {
	return spanner.Insert(r.Mutation())
}

func (r *LineItemsRow) InsertOrUpdate() *spanner.Mutation {
	return spanner.InsertOrUpdate(r.Mutation())
}

func (r *LineItemsRow) Update() *spanner.Mutation {
	return spanner.Update(r.Mutation())
}

func (r *LineItemsRow) InsertColumns(columns []string) *spanner.Mutation {
	return spanner.Insert(r.MutationForColumns(columns))
}

func (r *LineItemsRow) InsertOrUpdateColumns(columns []string) *spanner.Mutation {
	return spanner.InsertOrUpdate(r.MutationForColumns(columns))
}

func (r *LineItemsRow) UpdateColumns(columns []string) *spanner.Mutation {
	return spanner.Update(r.MutationForColumns(columns))
}

func (r *LineItemsRow) Mutation() (string, []string, []interface{}) {
	return "line_items", r.ColumnNames(), []interface{}{
		r.ShipperId,
		r.ShipmentId,
		r.LineNumber,
		r.Title,
		r.Quantity,
		r.WeightKg,
		r.VolumeM3,
	}
}

func (r *LineItemsRow) MutationForColumns(columns []string) (string, []string, []interface{}) {
	if len(columns) == 0 {
		columns = r.ColumnNames()
	}
	values := make([]interface{}, 0, len(columns))
	for _, column := range columns {
		switch column {
		case "shipper_id":
			values = append(values, r.ShipperId)
		case "shipment_id":
			values = append(values, r.ShipmentId)
		case "line_number":
			values = append(values, r.LineNumber)
		case "title":
			values = append(values, r.Title)
		case "quantity":
			values = append(values, r.Quantity)
		case "weight_kg":
			values = append(values, r.WeightKg)
		case "volume_m3":
			values = append(values, r.VolumeM3)
		default:
			panic(fmt.Errorf("table line_items does not have column %s", column))
		}
	}
	return "line_items", columns, values
}

func (r *LineItemsRow) PrimaryKey() LineItemsKey {
	return LineItemsKey{
		ShipperId:  r.ShipperId,
		ShipmentId: r.ShipmentId,
		LineNumber: r.LineNumber,
	}
}

type ListQuery struct {
	Where  spansql.BoolExpr
	Order  []spansql.Order
	Limit  int64
	Offset int64
}

type SpannerReadTransaction interface {
	Read(ctx context.Context, table string, keys spanner.KeySet, columns []string) *spanner.RowIterator
	ReadRow(ctx context.Context, table string, key spanner.Key, columns []string) (*spanner.Row, error)
	Query(ctx context.Context, statement spanner.Statement) *spanner.RowIterator
}
